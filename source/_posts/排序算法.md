---
title: 排序算法
date: 2017-11-30 20:56:02
tags: 算法
categories: basic
---
## 排序的定义及分类
排序：将无序输入的数据按有序排列

计算的时间复杂度（最差、平均、和最好性能），依据列表（list）的大小(n)。一般而言，好的性能是O(n log n)，且坏的性能是O(n2)。对于一个排序理想的性能是O(n)。仅使用一个抽象关键比较运算的排序算法总平均上总是至少需要O(n log n)。
内存使用量（以及其他电脑资源的使用）
稳定性：稳定排序算法会让原本有相等键值的纪录维持相对次序。也就是如果一个排序算法是稳定的，当有两个相等键值的纪录R和S，且在原本的列表中R出现在S之前，在排序过的列表中R也将会是在S之前。
依据排序的方法：插入、交换、选择、合并等等。
<!--more-->
### 分类
1.按稳定性(在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的相对次序保持不变,则称这种排序算法是稳定的。排序的稳定性需要从原理证明，而不稳定则秩序使用举例)分：

稳定排序：基数排序、冒泡排序、插入排序、折半插入排序、归并排序。

不稳定排序：堆排序、快速排序、希尔排序、 选择排序。

2.根据待排序记录数量及其在排序过程中涉及的存储器，可将排序方法分为两大类:

>内部排序, 指的是待排序记录存放在计算机存储器中进行的排序过程，内排序效率用比较次数来衡量，算法有：插入排序、选择排序、冒泡排序、堆排序、快速排序。
于比较的排序算法是不能突破O(NlogN)的。简单证明：
N个数有N!个可能的排列情况，也就是说基于比较的排序算法的判定树有N!个叶子结点，比较次数至少为log(N!)=O(NlogN)(斯特林公式)。

外部排序, 指的是待排序记录的数量很大，以至于内存一次不能容纳全部记录，在排序过程中尚需对外存进行访问的排序过程。但块与块之间不能保证有序,外排序用读/写外存的次数来衡量效率。外排序的块与块之间不能保证有序。但是排序的结果还是一个有序的。算法有：归并排序、计数排序、基数排序、桶排序。
排序类别	具体排序
交换排序	冒泡排序 鸡尾酒排序 奇偶排序 梳排序 侏儒排序 快速排序 臭皮匠排序 Bogo排序
选择排序	选择排序 堆排序 平滑排序 笛卡尔树排序 锦标赛排序 圈排序
插入排序	插入排序 希尔排序 伸展排序 二叉查找树排序 图书馆排序 耐心排序
归并排序	归并排序 梯级归并排序 振荡归并排序 多相归并排序 列表排序
分布排序	美国旗帜排序 珠排序 桶排序 爆炸排序 计数排序 鸽巢排序 相邻图排序 基数排序 闪电排序 插值排序
并发排序	双调排序器 Batcher归并网络 两两排序网络
混合排序	块排序 Tim排序 内省排序 Spread排序 J排序
其他	拓扑排序 煎饼排序 意粉排序
## 排序算法
### 1.插入排序
原理：对已经排序的数据从后向前扫描，将未排序的数据找到合适的位置插入数据。
插入排序

特点：
分类：稳定，内部排序
所需的额外空间:O(1)
数据结构：数组
最差时间复杂度：最坏情况为输入序列是降序排列的,此时时间复杂度O(n^2)
最优时间复杂度：最好情况为输入序列是升序排列的,此时时间复杂度O(n)
平均时间复杂度:O(n^2)
步骤如下：

1.将第一个元素默认为已经排好序
2.取出已经排序的序列的下一个元素，在已排序的序列中从后向前扫描。
3.如果该元素大于新元素，则向前扫描
4.重复步骤3,直到找到已排序的元素小于或等于新元素的位置。
5.将新元素插入到该位置后
6.重复2～5
```
   #include <stdio.h>
    int main(){
    int a[]={3,44,38,5,47,15,36,26,27,2,46,4,19,50,48};
    for(int i=1;i<(int)sizeof(a)/sizeof(int);i++){//将第一个元素视为已排序的，
        int j=i-1;
        int tmp=a[i];//申请额外的空间
        while(tmp<a[j]&&j>=0){//与已经排好序的每个比较
            a[j+1]=a[j];//满足条件的后移
            j--;
        }
        a[j+1]=tmp;//
        for(int k=0;k<=i;k++){
             printf("%d",a[k]);
             printf("%s"," ");
        }
         printf("\n");
    }
    return 0;
}
```
插入排序不适合对于数据量比较大的排序应用

### 2.插入排序的改进：二分插入排序
原理：在插入排序的基础上，接合二分查找
特点：
分类：稳定，内部排序
所需辅助空间 ：O(1)
时间复杂度： 最差时间复杂度 —- O(n^2)
最优时间复杂度 —- O(nlogn)
平均时间复杂度 —- O(n^2)
所需辅助空间 —— O(1)
步骤：
1.从第一个元素起，将其视为已经排好序
2.取排好序的下一个元素，将已排序的元素分为两段
3.比较已排元素的中间值，若该元素大于中间值则取后半段进行2操作，小于中间值取前半段进行2操作，
4.当元素与中间值相同，将后半段的元素后移,元素插入左边元素之后。
```
#include <stdio.h>
int main(){
     int a[]={3,44,38,5,47,15,36,26,27,2,46,4,19,50,48};
     int left,right,middle,tmp,i;
     for(i=1;i<sizeof(a)/sizeof(int);i++){
         tmp=a[i];
         left=0;
         right=i-1;
         while(right>=left){
             middle=(left+right)/2;
              if(a[middle]>tmp){
                  right=middle-1;
              }else{//最后一步时，会将left=middle
                  left=middle+1;
              }
         }
        for (int j = i - 1; j >= left; j--){    // 将欲插入新牌位置右边的牌整体向右移动一个单位
            a[j + 1] = a[j];            
        }
        a[left] =tmp; 
     }
    printf("二分插入排序结果：");
    for (i = 0; i <sizeof(a)/sizeof(int); i++)
    {
        printf("%d ", a[i]);
    }
    printf("\n");
}
```
当n较大时，二分插入排序的比较次数比直接插入排序的最差情况好得多，但比直接插入排序的最好情况要差,所当以元素初始序列已经接近升序时，直接插入排序比二分插入排序比较次数少。二分插入排序元素移动次数与直接插入排序相同，依赖于元素初始序列。

### 3.　插入排序的高效改进:希尔排序(递减增量排序、分组插入排序)
原理：初期选用较大的增量(d小于n)进行比较，对相隔增量的元素进行插入排序，然后缩小增量，最后增量为1，进行插入排序。
希尔排序
特点：
分类：不稳定，内部排序
最差时间复杂度 ：
根据步长序列的不同而不同。已知最好的为O(n(logn)^2)
最优时间复杂度 —- O(n)
平均时间复杂度 —- 根据步长序列的不同而不同。
所需辅助空间： O(1)
步骤：
1.设置步长d小于n，依据步长分组
2.在分组内进行插入排序
3.减小步长进行1～2的操作，直至d为1

```
#include <stdio.h>
//使用严格按照希尔排序定义的希尔基础排序
int main(){
    int a[]={49,38,65,97,26,13,27,49,55,4};
    int gap,i,tmp;
    int n=sizeof(a)/sizeof(int);
    for(gap=n/2;gap>0;gap/=2){//设置步长
     for(i=0;i<gap;i++){//分组
        for(int j=i+gap;j<n;j+=gap){//对分组后的数据进行插入排序
           if(a[j]<a[j-gap]){
             tmp=a[j];
             int k=j-gap;
             while(k>=0&&a[k]>tmp){//易错点，不要贪图思维上的懒惰，a[j]交换后，值变化
                 a[k+gap]=a[k];
                 k-=gap;
             }
             a[k+gap]=tmp;
            }
         }
      }
    }
      for(int f=0;f<n;f++){
        printf("%d",a[f]);
        printf("%s"," ");
    } 
    return 0;
}
```
代码优化希尔排序：

```
#include <stdio.h>
//优化希尔排序
int main(){
     int a[]={49,38,65,97,26,13,27,49,55,4};
     int j, gap; 
     int n=sizeof(a)/sizeof(int);    
    for (gap = n / 2; gap > 0; gap /= 2)  
        for (j = gap; j < n; j++)//从数组第gap个元素开始  
            if (a[j] < a[j - gap])//每个元素与自己组内的数据进行直接插入排序  
            {  
                int temp = a[j];  
                int k = j - gap;  
                while (k >= 0 && a[k] > temp)  
                {  
                    a[k + gap] = a[k];  
                    k -= gap;  
                }  
                a[k + gap] = temp;  
            }  
      for(int f=0;f<n;f++){
        printf("%d",a[f]);
        printf("%s"," ");
    } 
    return 0;
}
```
最优:

```
#include <stdio.h>
#include <utility>
int main(){
     int i, j, gap; 
     int a[]={49,38,65,97,26,13,27,49,55,4}; 
     int n=sizeof(a)/sizeof(int);    
    for (gap = n / 2; gap > 0; gap /= 2)  {
        for (i = gap; i < n; i++)  {
            for (j = i - gap; j >= 0 && a[j] > a[j + gap]; j -= gap) { 
                std::swap(a[j], a[j + gap]);
            }
        }
    }
     for(int f=0;f<n;f++){
        printf("%d",a[f]);
        printf("%s"," ");
    } 
    return 0;
}
```
### 4.冒泡排序
原理：重复地走访过要排序的元素，一次比较相邻两个元素，如果他们的顺序错误就把他们调换过来，直到没有元素再需要交换，排序完成。
冒泡排序
特点：
分类：稳定，内部排序
时间复杂度：
最差时间复杂度 —- O(n^2)
最优时间复杂度 —- 如果能在内部循环第一次运行时,使用一个旗标来表示有无需要交换的可能,可以把最优时间复杂度降低到O(n)
平均时间复杂度 —- O(n^2)
所需额外空间：O(1)
步骤：
1.比较序列中相邻的两个元素大小，并交换，从头到尾末尾为最大的元素
2.从头到倒数第二个元素，重复1操作

```
 #include <stdio.h>
int main(){
     int a[]={3,44,38,5,47,15,36,26,27,2,46,4,19,50,48};
     for(int i=sizeof(a)/sizeof(int)-1;i>=0;i--){
         for(int j=0;j<=i-1;j++){
             if(a[j]>a[j+1]){
                 int temp=a[j];
                 a[j]=a[j+1];
                 a[j+1]=temp;
             }
         }
     }
     for(int k=0;k<sizeof(a)/sizeof(int);k++){
         printf("%d",a[k]);
         printf("%s"," ");
     }
    return 0;
}
```
冒泡排序的改进：冒泡排序是最容易了解和实现的排序算法之一，但它对于少数元素之外的数列排序是很没有效率的。

### 5.冒泡排序的改进：定向冒泡排序（鸡尾酒排序）
原理：对序列进行从低到高再从高到底的排序
冒泡排序
特点：
分类:内部排序、稳定
时间复杂度：
最差时间复杂度 —- O(n^2)
最优时间复杂度 —- 如果序列在一开始已经大部分排序过的话,会接近O(n)。如：（2，3，4，5，1）
平均时间复杂度 —- O(n^2)
所需辅助空间 ：O(1)
```
  #include <stdio.h>
int main(){
    int a[]={3,44,38,5,47,15,36,26,27,2,46,4,19,50,48};
    int left=0,right=sizeof(a)/sizeof(int);
    while(left<right){
        for(int i=0;i<right;i++){
            if(a[i]>a[i+1]){
                int temp=a[i+1];
                a[i+1]=a[i];
                a[i]=temp;
            }
        }
        right--;
        for(int j=right;j>=left;j--){
            if(a[j]>a[j+1]){
                int temp=a[j+1];
                a[j+1]=a[j];
                a[j]=temp;
            }
        }
        left++;
    }
    for(int k=0;k<sizeof(a)/sizeof(int);k++){
         printf("%d",a[k]);
         printf("%s"," ");
     }
}
```
在乱数序列的状态下，鸡尾酒排序与冒泡排序的效率都很差劲。

### 6.选择排序
原理：在未排序的序列中依次找出最小(大)的元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，放到已排序序列的末尾。
选择排序
特点：
分类：内部排序、不稳定
时间啊复杂度：最差时间复杂度 —- O(n^2)
最优时间复杂度 —- O(n^2)
平均时间复杂度 —- O(n^2)
所需的额外空间：O(1)

```
#include <stdio.h>
int main(){
     int a[]={3,44,38,5,47,15,36,26,27,2,46,4,19,50,48};
     int n=sizeof(a)/sizeof(int);
     int min=0;
     for(int i=0;i<=n-2;i++){
         min=i;
         for(int j=i+1;j<=n-1;j++){
             if(a[j]<a[min]){
                 min=j;
             }
         }
         if(min!=i){
            int temp=a[i];
            a[i]=a[min];
            a[min]=temp;
         }
     }
      for(int k=0;k<=n-1;k++){
             printf("%d",a[k]);
             printf("%s"," ");
        }
    return 0;
}
```
### 7.堆排序
原理：数据结构堆设计的一种排序算法。把最大堆堆顶的最大数取出，将剩余的堆继续调整为最大堆，再次将堆顶的最大数取出，这个过程持续到剩余数只有一个时结束。

堆是一个近似完全二叉树的结构（通常堆是通过一维数组来实现的），并同时满足堆的性质：即子结点的键值总是小于（或者大于）它的父节点。
堆排序
分类： 内部比较排序、不稳定
数据结构：数组
时间复杂度：
最差时间复杂度 —- O(nlogn)
最优时间复杂度 —- O(nlogn)
平均时间复杂度 —- O(nlogn)
所需辅助空间： O(1)
步骤：
1.创建堆
2.把堆顶元素(最大值)和堆尾元素互换，对断尾后剩余部分重新构造大（小）根堆
3.重复2操作，直到取完所有的元素
4.把元素按取出的顺序排列，即得到一个有序数组
```
   #include <stdio.h>
//交换函数
void exchange(int a[],int i,int j){
    int temp=a[i];
    a[i]=a[j];
    a[j]=temp;
}
//调整堆函数
void adjust(int a[],int k,int size){//调整节点i及其后代调整为最大根
     int leftChild=2*k+1;//获取节点的左子树
     int rightChild=2*k+2;//获取节点的右子树
     int largest=k;//记录最大值的位置
     if(leftChild<=size&&a[leftChild]>a[largest]){//先比较当前节点的值与左子树
         largest=leftChild;
     }
     if(rightChild<=size&& a[rightChild]>a[largest]){
         largest=rightChild;
     }
     if(largest!=k){//创建大根堆
        exchange(a,k,largest);//调整的过程是从最底层开始，调整当前节点
        adjust(a,largest,size);//当不为底层时递归调整
     }
}
//创建大根堆
void heap(int a[],int size){
    for(int i=size/2;i>=0;i--){//从中间节点开始，依据二叉树的特点
        adjust(a,i,size);
    }
}
int main(){
      int a[]={3,44,38,5,47,15,36,26,27,2,46,4,19,50,48};
      int size=sizeof(a)/sizeof(int)-1;
      heap(a,size);//创建堆
     for (int i = size; i >= 1; i--){
        exchange(a, 0, i); // 将堆顶元素(当前最大值)与堆的最后一个元素互换(该操作很有可能把后面元素的稳定性打乱,所以堆排序是不稳定的排序算法)
        size--;                     // 从堆中去掉最后一个元素
        adjust(a, 0,size);                  // 从新的堆顶元素开始进行堆调整
      }
      for (int i = 0; i <sizeof(a)/sizeof(int); i++)
      {
        printf("%d ", a[i]);
     }
    printf("\n");
    return 0;
    }
```
### 8.快速排序
原理：采用思想是分治思想，找出一个元素（理论上可以随便找一个）作为基准(pivot),然后对数组进行分区操作,使基准左边元素的值都不大于基准值,基准右边的元素值 都不小于基准值，如此作为基准的元素调整到排序后的正确位置。递归快速排序，将其他n-1个元素也调整到排序后的正确位置。

```
#include <stdio.h>
int a[101],n;//定义全局变量，这两个变量需要在子函数中使用
void quicksort(int left,int right)
{
    int i,j,t,temp;
    if(left>right)
       return;
                                    
    temp=a[left]; //temp中存的就是基准数
    i=left;
    j=right;
    while(i!=j){
       //顺序很重要，要先从右边开始找
       while(a[j]>=temp && i<j)
                j--;
       //再找右边的
       while(a[i]<=temp && i<j)
                i++;
       //交换两个数在数组中的位置
       if(i<j){
                t=a[i];
                a[i]=a[j];
                a[j]=t;
       }
    }
    //最终将基准数归位
    a[left]=a[i];
    a[i]=temp;
    quicksort(left,i-1);//继续处理左边的，这里是一个递归的过程
    quicksort(i+1,right);//继续处理右边的 ，这里是一个递归的过程
}
int main(){
    int i,j,t;
    //读入数据
    scanf("%d",&n);
    for(i=1;i<=n;i++)
       scanf("%d",&a[i]);
    quicksort(1,n); //快速排序调用
                                 
    //输出排序后的结果
    for(i=1;i<=n;i++)
        printf("%d ",a[i]);
    getchar();getchar();
    return 0;
}
```
### 9.归并排序
原理：把原始数组分成若干子数组,对每一个子数组进行排序,
继续把子数组与子数组合并,合并后仍然有序,直到全部合并完,形成有序的数组

未完待续.....