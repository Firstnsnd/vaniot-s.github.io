<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Vaniot</title>
  
  <subtitle>blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://vaniot-s.github.io/"/>
  <updated>2021-05-06T21:05:19.536Z</updated>
  <id>https://vaniot-s.github.io/</id>
  
  <author>
    <name>Vaniot</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>prometheus指南</title>
    <link href="https://vaniot-s.github.io/2019/09/11/prometheus%E6%8C%87%E5%8D%97/"/>
    <id>https://vaniot-s.github.io/2019/09/11/prometheus指南/</id>
    <published>2019-09-11T17:00:59.000Z</published>
    <updated>2021-05-06T21:05:19.536Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>prometheus 的数据存储类型为时间序列，prometheus周期性的从应用或pushgateway(应用将metrics发送到pushgateway)中拉取metrics的当前value</p><h2 id="一-监控指标-Metrics-："><a href="#一-监控指标-Metrics-：" class="headerlink" title="一.监控指标(Metrics)："></a>一.监控指标(Metrics)：</h2><h4 id="1-组成"><a href="#1-组成" class="headerlink" title="1.组成"></a>1.组成</h4><ul><li>指标(metric)：metric name和描述当前样本特征的labelsets;</li><li>时间戳(timestamp)：一个精确到毫秒的时间戳(查询时timestamp不可见);</li><li>样本值(value)： 一个folat64的浮点型数据表示当前样本的值。<br><strong>metrics示例：</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;--metric  name--&gt;&lt;-------------metrics labels------&gt; &lt;--timestamp --&gt;     &lt;--value--&gt;</span><br><span class="line">http_request_total&#123;status=&quot;200&quot;, method=&quot;GET&quot;&#125;@1434417560938 =&gt; 94355</span><br><span class="line">http_request_total&#123;status=&quot;200&quot;, method=&quot;GET&quot;&#125;@1434417561287 =&gt; 94334</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>注意：metric部分完全相同为同一个metric</p></blockquote><h4 id="2-四种类型："><a href="#2-四种类型：" class="headerlink" title="2.四种类型："></a>2.四种类型：</h4><ul><li>Counter 计数器指标其工作方式和计数器一样，<strong>只增不减</strong>记录某些事件发生的次数。</li><li>Gauge表盘<strong>可增可减</strong>的类似于仪表盘，用于反映当前系统的状态</li><li>分析数据分布情况：<ul><li>Histogram 柱状图，用于统计一些数据分布的情况，用于计算在一定范围内的分布情况，同时还提供了度量指标值的总和</li><li>Summary  摘要，计算在一定时间窗口范围内度量指标对象的总数以及所有对量指标值的总和。</li></ul></li></ul><p><strong>四种类型示例：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># histogram 类型示例</span><br><span class="line">&lt;---------------------------metric name-----------------------&gt;  &lt;value range&gt; &lt;count&gt;</span><br><span class="line">prometheus_tsdb_compaction_chunk_range_bucket&#123;le=&quot;1000&quot;&#125;          0</span><br><span class="line">prometheus_tsdb_compaction_chunk_range_bucket&#123;le=&quot;4000&quot;&#125;          0</span><br><span class="line">prometheus_tsdb_compaction_chunk_range_bucket&#123;le=&quot;16000&quot;&#125;        100</span><br><span class="line">prometheus_tsdb_compaction_chunk_range_bucket&#123;le=&quot;64000&quot;&#125;        160</span><br><span class="line">prometheus_tsdb_compaction_chunk_range_bucket&#123;le=&quot;256000&quot;&#125;     260 # value 小于25600的个数统计，包含前一段的数据</span><br><span class="line">prometheus_tsdb_compaction_chunk_range_bucket&#123;le=&quot;1024000&quot;&#125;  780</span><br><span class="line">prometheus_tsdb_compaction_chunk_range_bucket&#123;le=&quot;+Inf&quot;&#125;           780 # prometheus 自添加的范围</span><br><span class="line">prometheus_tsdb_compaction_chunk_range_sum 1.1540798e+09  #value 统计,prometheus自行处理</span><br><span class="line">prometheus_tsdb_compaction_chunk_range_count 780  #个数总计，prometheus自行处理</span><br><span class="line"></span><br><span class="line"># summary 类型示例</span><br><span class="line">&lt;---------metric name-----&gt;&lt;quantile range&gt;  &lt;value&gt;</span><br><span class="line">go_gc_duration_seconds&#123;quantile=&quot;0&quot;&#125;        3.1888e-05</span><br><span class="line">go_gc_duration_seconds&#123;quantile=&quot;0.25&quot;&#125; 3.6715e-05 # 25%小于3.6715e-05</span><br><span class="line">go_gc_duration_seconds&#123;quantile=&quot;0.5&quot;&#125;    5.1522e-05</span><br><span class="line">go_gc_duration_seconds&#123;quantile=&quot;0.75&quot;&#125; 8.1027e-05</span><br><span class="line">go_gc_duration_seconds&#123;quantile=&quot;1&quot;&#125;      0.000161162</span><br><span class="line">go_gc_duration_seconds_sum 0.001803144 # gc的总时间，prometheus自行处理</span><br><span class="line">go_gc_duration_seconds_count 27 #gc 的次数，prometheus自行处理</span><br></pre></td></tr></table></figure></p><h2 id="二-应用埋点："><a href="#二-应用埋点：" class="headerlink" title="二.应用埋点："></a>二.应用埋点：</h2><h4 id="1-前提-监控的规范配置-："><a href="#1-前提-监控的规范配置-：" class="headerlink" title="1.前提(监控的规范配置)："></a>1.前提(监控的规范配置)：</h4><p>prometheus支持自动发现机制，需要我们在应用部署的yaml添加配置支持，分为service和pod,某些部署应用只有pod没有service，这种情况只能在pod上加配置，通过pods采集metrics。如果有service，就无需在pod加配置，直接在service上加即可。否则，prometheus将采集两次数据，service-endpoints最终也会落到pod上。</p><h4 id="pod"><a href="#pod" class="headerlink" title="pod"></a>pod</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">metadata:</span></span><br><span class="line">    <span class="attr">annotations:</span></span><br><span class="line">        <span class="string">prometheus.io/scrape，为true则会将pod作为监控目标。</span></span><br><span class="line">        <span class="string">prometheus.io/path，默认为/metrics</span></span><br><span class="line">        <span class="string">prometheus.io/port</span> <span class="string">,</span> <span class="string">端口</span></span><br><span class="line">   <span class="attr">labels:</span>   <span class="comment"># 添加额外的信息，在采集时填入metrics labels</span></span><br></pre></td></tr></table></figure><blockquote><p>注意：经过测试，一个POD只支持一个path的配置，当一个POD中有多个container的metrics,考虑使用pushgateway,此时应当在采集时区分来自应用，最佳的做法:分开部署。</p></blockquote><h4 id="service-endpoints"><a href="#service-endpoints" class="headerlink" title="service-endpoints"></a>service-endpoints</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">metadata:</span></span><br><span class="line">    <span class="attr">annotations:</span></span><br><span class="line">       <span class="string">prometheus.io/scrape，为true则会将pod作为监控目标。</span></span><br><span class="line">       <span class="string">prometheus.io/path，默认为/metrics</span></span><br><span class="line">       <span class="string">prometheus.io/port</span> <span class="string">,</span> <span class="string">端口</span></span><br><span class="line">       <span class="string">prometheus.io/scheme</span> <span class="string">默认http，如果为了安全设置了https，此处需要改为https</span></span><br><span class="line">   <span class="attr">labels:</span>   <span class="comment"># 添加额外的信息，在采集时填入metrics labels</span></span><br></pre></td></tr></table></figure><h4 id="2-开发"><a href="#2-开发" class="headerlink" title="2.开发"></a>2.开发</h4><p>在应用中埋点，需要引入对应语言的<a href="https://github.com/prometheus" target="_blank" rel="noopener">prometheus库</a>.<br><strong>埋点的原理：</strong>埋点的产生的metrics将一直在内存中，依据应用的运行状态更新value,直到应用停止运行<br>适用于：</p><ul><li>记录系统的资源使用情况，</li><li>应用的运行状态</li><li><p>错误发生的计数<br>…</p><p>应用埋点产生可控的metrics,metrics不应当用于记录用户的行为，随着运行时长(用户增加)，产生大量metrics，占满内存。需要持久化与用户强相关的数据，不应当使用prometheus，metrics只用记录应用运行状态，存于内存中。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;p&gt;prometheus 的数据存储类型为时间序列，prometheus周期性的
      
    
    </summary>
    
      <category term="basic" scheme="https://vaniot-s.github.io/categories/basic/"/>
    
    
      <category term="proemtheus，k8s" scheme="https://vaniot-s.github.io/tags/proemtheus%EF%BC%8Ck8s/"/>
    
  </entry>
  
  <entry>
    <title>K8S搭建</title>
    <link href="https://vaniot-s.github.io/2019/06/04/k8s/"/>
    <id>https://vaniot-s.github.io/2019/06/04/k8s/</id>
    <published>2019-06-04T02:01:01.000Z</published>
    <updated>2021-05-06T21:05:19.536Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">sudo swapoff -a</span><br><span class="line"></span><br><span class="line">sudo apt-get update</span><br><span class="line"></span><br><span class="line">sudo apt-get install \</span><br><span class="line">    apt-transport-https \</span><br><span class="line">    ca-certificates \</span><br><span class="line">    curl \</span><br><span class="line">    software-properties-common</span><br><span class="line"></span><br><span class="line">curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -</span><br><span class="line"></span><br><span class="line">sudo add-apt-repository \</span><br><span class="line">    <span class="string">"deb [arch=amd64] https://download.docker.com/linux/ubuntu \</span></span><br><span class="line"><span class="string">    <span class="variable">$(lsb_release -cs)</span> \</span></span><br><span class="line"><span class="string">    stable"</span></span><br><span class="line"></span><br><span class="line"> sudo apt install -y docker.io</span><br><span class="line"></span><br><span class="line">sudo systemctl start docker</span><br><span class="line"></span><br><span class="line">sudo systemctl <span class="built_in">enable</span> docker</span><br><span class="line"></span><br><span class="line">sudo apt-get update &amp;&amp; sudo apt-get install -y apt-transport-https &amp;&amp; curl -s https://packages.cloud.google.com/apt/doc/apt-key.gpg | sudo apt-key add -</span><br><span class="line"></span><br><span class="line"> <span class="built_in">echo</span> <span class="string">"deb http://apt.kubernetes.io/ kubernetes-xenial main"</span> | sudo tee -a /etc/apt/sources.list.d/kubernetes.list &amp;&amp; sudo apt-get update</span><br><span class="line"></span><br><span class="line"> sudo apt install -y kubeadm  kubelet kubernetes-cni</span><br><span class="line"> systemctl <span class="built_in">enable</span> kubelet &amp;&amp; systemctl start kubelet</span><br><span class="line"></span><br><span class="line"><span class="comment"># master</span></span><br><span class="line"> kubeadm init --kubernetes-version=1.15.0</span><br><span class="line"></span><br><span class="line">mkdir -p <span class="variable">$HOME</span>/.kube</span><br><span class="line">sudo cp -i /etc/kubernetes/admin.conf <span class="variable">$HOME</span>/.kube/config</span><br><span class="line">sudo chown $(id -u):$(id -g) <span class="variable">$HOME</span>/.kube/config</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">kubectl apply -f <span class="string">"https://cloud.weave.works/k8s/net?k8s-version=<span class="variable">$(kubectl version | base64 | tr -d '\n')</span>"</span></span><br><span class="line"><span class="comment">## 或者</span></span><br><span class="line">kubectl apply -f https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml</span><br><span class="line"><span class="comment"># worker</span></span><br><span class="line">kubeadm join 192.168.1.18:6443 --token sexemg.1wqeqweqweqwew \</span><br><span class="line">    --discovery-token-ca-cert-hash sha256:2153e47c21dbbaasdasd64735d4aa0546fdb60231 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">kubeadm reset</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;h3 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerli
      
    
    </summary>
    
      <category term="basic" scheme="https://vaniot-s.github.io/categories/basic/"/>
    
    
      <category term="k8s" scheme="https://vaniot-s.github.io/tags/k8s/"/>
    
  </entry>
  
  <entry>
    <title>认证机制</title>
    <link href="https://vaniot-s.github.io/2019/01/18/%E8%AE%A4%E8%AF%81%E6%9C%BA%E5%88%B6/"/>
    <id>https://vaniot-s.github.io/2019/01/18/认证机制/</id>
    <published>2019-01-18T09:20:04.000Z</published>
    <updated>2021-05-06T21:05:19.536Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="Cookie-Session（适用于WEB）"><a href="#Cookie-Session（适用于WEB）" class="headerlink" title="Cookie/Session（适用于WEB）"></a>Cookie/Session（适用于WEB）</h3><p> 在请求时在服务端创建一个Session对象(可以存于服务器内存，内存数据库，文件等),同时创建一系列的Cookie键值对保存于浏览器的，Cookie会在HTTP请求时一起发送，通过匹配Cookie与session对象匹配来实现状态管理。</p><h3 id="Basic-Auth"><a href="#Basic-Auth" class="headerlink" title="Basic Auth"></a>Basic Auth</h3><p> HTTP基本认证，客户端在请求时提供<code>用户名</code>和<code>口令</code>的形式登录验证，使用时将<code>用户名</code>和<code>口令</code>使用<code>:</code>链接，再base64加密后使用<code>Authorization</code>发送给服务端,在服务端直接使用字段验证<br> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line"><span class="keyword">var</span> auth=user+<span class="string">':'</span>+password;</span><br><span class="line">xhr.setRequestHeader(<span class="string">'Authorization'</span>, auth);</span><br><span class="line">xhr.open(<span class="string">'GET'</span>,url)</span><br></pre></td></tr></table></figure></p><h3 id="Token"><a href="#Token" class="headerlink" title="Token"></a>Token</h3><p>   Token认证是在用户登录成功时会为其生成在一段时间有效唯一的token,将其保存客户端和服务端，用户在请求时带上token用于服务端验证。</p><h3 id="JWT-认证"><a href="#JWT-认证" class="headerlink" title="JWT 认证"></a>JWT 认证</h3><p>JWT(JSON WEB Token)用于在身份提供者和服务提供者间传递被人整用户身份信息，便于从资源服务器获取资源，该Token可用于被认证和加密</p><h4 id="Jwt认证流程"><a href="#Jwt认证流程" class="headerlink" title="Jwt认证流程"></a>Jwt认证流程</h4><ol><li>客户端调用登录接口（或者获取 token 接口），传入用户名密码。</li><li>服务端请求身份认证中心，确认用户名密码正确。</li><li>服务端创建 JWT，返回给客户端。</li><li>客户端拿到 JWT，进行存储（可以存储在缓存中，也可以存储在数据库中，如果是浏览器，可以存储在 Cookie 中）在后续请求中，在 HTTP 请求头中加上 JWT。</li><li>服务端校验 JWT，校验通过后，返回相关资源和数据。</li></ol><h4 id="JWT结构"><a href="#JWT结构" class="headerlink" title="JWT结构"></a>JWT结构</h4><p>JWT 是由三段信息构成的，第一段为头部（Header），第二段为载荷（Payload)，第三段为签名（Signature）。每一段内容都是一个 JSON 对象，将每一段 JSON 对象采用 BASE64 编码，将编码后的内容用. 链接一起就构成了 JWT 字符串。如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">header.payload.signature</span><br></pre></td></tr></table></figure></p><ol><li>头部（Header）</li></ol><p>头部用于描述关于该 JWT 的最基本的信息，例如其类型以及签名所用的算法等。这也可以被表示成一个 JSON 对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">&quot;typ&quot;: &quot;JWT&quot;,</span><br><span class="line">&quot;alg&quot;: &quot;HS256&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在头部指明了签名算法是 HS256 算法。</p><ol start="2"><li>载荷（payload）</li></ol><p>载荷就是存放有效信息的地方。有效信息包含三个部分：</p><ul><li><p>标准中注册的声明</p></li><li><p>公共的声明</p></li><li><p>私有的声明</p></li></ul><p>标准中注册的声明（建议但不强制使用）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">iss：JWT 签发者</span><br><span class="line"></span><br><span class="line">sub：JWT 所面向的用户</span><br><span class="line"></span><br><span class="line">aud：接收 JWT 的一方</span><br><span class="line"></span><br><span class="line">exp：JWT 的过期时间，这个过期时间必须要大于签发时间</span><br><span class="line"></span><br><span class="line">nbf：定义在什么时间之前，该 JWT 都是不可用的</span><br><span class="line"></span><br><span class="line">iat：JWT 的签发时间</span><br><span class="line"></span><br><span class="line">jti：JWT 的唯一身份标识，主要用来作为一次性 token, 从而回避重放攻击。</span><br></pre></td></tr></table></figure></p><p>公共的声明 ：</p><p>公共的声明可以添加任何的信息，一般添加用户的相关信息或其他业务需要的必要信息. 在客户端可不应添加敏感信息。</p><p>私有的声明 ：</p><p>私有声明是提供者和消费者所共同定义的声明，不存放敏感信息，因为 base64 是对称解密的，意味着该部分信息可以归类为明文信息。</p><p>示例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123; &quot;iss&quot;: &quot;Online JWT Builder&quot;,</span><br><span class="line"> &quot;iat&quot;: 1416797419,</span><br><span class="line"> &quot;exp&quot;: 1448333419,</span><br><span class="line"> &quot;aud&quot;: &quot;www.primeton.com&quot;,</span><br><span class="line"> &quot;sub&quot;: &quot;devops@primeton.com&quot;,</span><br><span class="line"> &quot;GivenName&quot;: &quot;dragon&quot;,</span><br><span class="line"> &quot;Surname&quot;: &quot;wang&quot;,</span><br><span class="line"> &quot;admin&quot;: true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ol start="3"><li>签名（signature)</li></ol><p>创建签名需要使用 Base64 编码后的 header 和 payload 以及一个秘钥。将 base64 加密后的 header 和 base64 加密后的 payload 使用. 连接组成的字符串，通过 header 中声明的加密方式进行加盐 secret 组合加密，然后就构成了 jwt 的第三部分。</p><p>比如：<code>HMACSHA256(base64UrlEncode(header) + &quot;.&quot; + base64UrlEncode(payload), secret)</code></p><p>JWT 的优点：</p><ol><li>跨语言，JSON 的格式保证了跨语言的支撑</li><li>基于 Token，无状态</li><li>占用字节小，便于传输</li></ol><p>关于 Token 注销：</p><p>Token 的注销，由于 Token 不存储在服务端，由客户端存储，当用户注销时，Token 的有效时间还没有到，还是有效的。所以如何在用户注销登录时让 Token 注销是一个要关注的点。一般有如下几种方式：</p><ol><li>Token 存储在 Cookie 中，这样客户端注销时，自然可以清空掉</li><li>注销时，将 Token 存放到分布式缓存中，每次校验 Token 时区检查下该 Token 是否已注销。不过这样也就失去了快速校验 Token 的优点。</li><li>多采用短期令牌，比如令牌有效期是 20 分钟，这样可以一定程度上降低注销后 Token 可用性的风险。</li></ol><h3 id="Oauth"><a href="#Oauth" class="headerlink" title="Oauth"></a>Oauth</h3><p>用户在使用时不将用户信息传给服务提供者，客户端向授权服务器请求授权，用户成功授权后授权服务器向客户端发放令牌，客户端再使用令牌向资源服务器请求资源。<br>  Oatuh的登录流程：<br>  <img src="https://raw.githubusercontent.com/vaniot-s/picture/master/Oauth/Oauth.png" alt="Oauth"></p><blockquote><p>详细 <a href="http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html" target="_blank" rel="noopener">理解OAuth 2.0</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;h3 id=&quot;Cookie-Session（适用于WEB）&quot;&gt;&lt;a href=&quot;
      
    
    </summary>
    
      <category term="basic" scheme="https://vaniot-s.github.io/categories/basic/"/>
    
    
      <category term="认证机制" scheme="https://vaniot-s.github.io/tags/%E8%AE%A4%E8%AF%81%E6%9C%BA%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>redis源码解析--sds</title>
    <link href="https://vaniot-s.github.io/2019/01/11/redis%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-sds/"/>
    <id>https://vaniot-s.github.io/2019/01/11/redis源码解析-sds/</id>
    <published>2019-01-11T22:23:19.000Z</published>
    <updated>2021-05-06T21:05:19.536Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css">]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;
      
    
    </summary>
    
      <category term="basic" scheme="https://vaniot-s.github.io/categories/basic/"/>
    
    
      <category term="Redis" scheme="https://vaniot-s.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>redis源码解析--双向链表</title>
    <link href="https://vaniot-s.github.io/2019/01/06/redis%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/"/>
    <id>https://vaniot-s.github.io/2019/01/06/redis源码解析-双向链表/</id>
    <published>2019-01-06T16:57:57.000Z</published>
    <updated>2021-05-06T21:05:19.536Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote><p>redis <a href="https://github.com/antirez/redis/blob/5.0/src/adlist.h" target="_blank" rel="noopener">https://github.com/antirez/redis/blob/5.0/src/adlist.h</a><br><a href="https://github.com/antirez/redis/blob/5.0/src/adlist.c" target="_blank" rel="noopener">https://github.com/antirez/redis/blob/5.0/src/adlist.c</a></p></blockquote><h2 id="结构体的定义"><a href="#结构体的定义" class="headerlink" title="结构体的定义"></a>结构体的定义</h2><p>结构体的实现,双向链表的相关定义于<code>adlist.h</code>中<br>节点:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">prev</span>;</span> <span class="comment">//前一个节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">next</span>;</span> <span class="comment">//后一个节点</span></span><br><span class="line">    <span class="keyword">void</span> *value; <span class="comment">//节点的值</span></span><br><span class="line">&#125; listNode;</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>迭代器:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listIter</span> &#123;</span></span><br><span class="line">    listNode *next; <span class="comment">//指向节点</span></span><br><span class="line">    <span class="keyword">int</span> direction; <span class="comment">//迭代器的方向 迭代方向由常量AL_START_HEAD及AL_START_TAIL 指示</span></span><br><span class="line">&#125; listIter;</span><br></pre></td></tr></table></figure></p><p>链表结构:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">list</span> &#123;</span></span><br><span class="line">    listNode *head; <span class="comment">//链表的头结点</span></span><br><span class="line">    listNode *tail;<span class="comment">//链表的尾节点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//函数指针如类中的成员函数</span></span><br><span class="line">    <span class="keyword">void</span> *(*dup)(<span class="keyword">void</span> *ptr); <span class="comment">//复制</span></span><br><span class="line">    <span class="keyword">void</span> (*<span class="built_in">free</span>)(<span class="keyword">void</span> *ptr); <span class="comment">//清空</span></span><br><span class="line">    <span class="keyword">int</span> (*match)(<span class="keyword">void</span> *ptr, <span class="keyword">void</span> *key); <span class="comment">//匹配链表节点的值</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> len; <span class="comment">//链表的长度</span></span><br><span class="line">&#125; <span class="built_in">list</span>;</span><br></pre></td></tr></table></figure></p><p>list链表结构:<br><img src="https://raw.githubusercontent.com/vaniot-s/picture/master/redis/Source/adlist/List.png" alt="链表结构图"></p><h2 id="链表的操作"><a href="#链表的操作" class="headerlink" title="链表的操作"></a>链表的操作</h2><h3 id="创建链表"><a href="#创建链表" class="headerlink" title="创建链表"></a>创建链表</h3><p>创建空链表<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">list</span> *<span class="title">listCreate</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list</span> *<span class="title">list</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((<span class="built_in">list</span> = zmalloc(<span class="keyword">sizeof</span>(*<span class="built_in">list</span>))) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//初始化属性</span></span><br><span class="line">    <span class="built_in">list</span>-&gt;head = <span class="built_in">list</span>-&gt;tail = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">list</span>-&gt;len = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">list</span>-&gt;dup = <span class="literal">NULL</span>;  <span class="comment">//</span></span><br><span class="line">    <span class="built_in">list</span>-&gt;<span class="built_in">free</span> = <span class="literal">NULL</span>; <span class="comment">//</span></span><br><span class="line">    <span class="built_in">list</span>-&gt;match = <span class="literal">NULL</span>; <span class="comment">//</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>; <span class="comment">//返回链表</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="链表的删除操作"><a href="#链表的删除操作" class="headerlink" title="链表的删除操作"></a>链表的删除操作</h3><p>清空链表中的元素,不删除链表本身:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">listEmpty</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>)</span> <span class="comment">//O(n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> len;</span><br><span class="line">    listNode *current, *next; <span class="comment">//指向当前,接下来的节点</span></span><br><span class="line"></span><br><span class="line">    current = <span class="built_in">list</span>-&gt;head; <span class="comment">//指向头结点</span></span><br><span class="line">    len = <span class="built_in">list</span>-&gt;len; <span class="comment">//链表的长度</span></span><br><span class="line">    <span class="keyword">while</span>(len--) &#123; <span class="comment">//</span></span><br><span class="line">        next = current-&gt;next; <span class="comment">//</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">list</span>-&gt;<span class="built_in">free</span>) <span class="built_in">list</span>-&gt;<span class="built_in">free</span>(current-&gt;value);  <span class="comment">//是否有自带的free方法,先使用释放当前值</span></span><br><span class="line">        zfree(current); <span class="comment">//释放节点</span></span><br><span class="line">        current = next; <span class="comment">//指向下一个节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">list</span>-&gt;head = <span class="built_in">list</span>-&gt;tail = <span class="literal">NULL</span>; <span class="comment">//循环清空</span></span><br><span class="line">    <span class="built_in">list</span>-&gt;len = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>释放链表:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">listRelease</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>)</span> <span class="comment">//O(n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    listEmpty(<span class="built_in">list</span>); <span class="comment">//释放链表中的元素</span></span><br><span class="line">    zfree(<span class="built_in">list</span>);<span class="comment">//释放链表</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="在链表中添加元素"><a href="#在链表中添加元素" class="headerlink" title="在链表中添加元素"></a>在链表中添加元素</h3><p>对于链表的指针添加操作.三种方法,若链表为空或添加到链表头(尾),采用<code>ListAddNodeHead()</code>或<code>ListAddNodeTail()</code>其时间复杂度为$O(1)$,不为空<code>listInsertNode</code>时间复杂度仍为$O(1)$.<br>头部添加<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">list</span> *<span class="title">listAddNodeHead</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, <span class="keyword">void</span> *value)</span> <span class="comment">//O(1)头插法</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    listNode *node; <span class="comment">//node</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((node = zmalloc(<span class="keyword">sizeof</span>(*node))) == <span class="literal">NULL</span>) <span class="comment">//申请空间</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    node-&gt;value = value; <span class="comment">//将链表值复制</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">list</span>-&gt;len == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//第一个节点</span></span><br><span class="line">        <span class="built_in">list</span>-&gt;head = <span class="built_in">list</span>-&gt;tail = node;</span><br><span class="line">        node-&gt;prev = node-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        node-&gt;prev = <span class="literal">NULL</span>;</span><br><span class="line">        node-&gt;next = <span class="built_in">list</span>-&gt;head;</span><br><span class="line">        <span class="built_in">list</span>-&gt;head-&gt;prev = node;</span><br><span class="line">        <span class="built_in">list</span>-&gt;head = node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">list</span>-&gt;len++;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>尾部添加<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">list</span> *<span class="title">listAddNodeTail</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, <span class="keyword">void</span> *value)</span> <span class="comment">//O(1)尾插法</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    listNode *node;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((node = zmalloc(<span class="keyword">sizeof</span>(*node))) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    node-&gt;value = value;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">list</span>-&gt;len == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">list</span>-&gt;head = <span class="built_in">list</span>-&gt;tail = node;</span><br><span class="line">        node-&gt;prev = node-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        node-&gt;prev = <span class="built_in">list</span>-&gt;tail;</span><br><span class="line">        node-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">list</span>-&gt;tail-&gt;next = node;</span><br><span class="line">        <span class="built_in">list</span>-&gt;tail = node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">list</span>-&gt;len++;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在指定的位置添加<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">list</span> *<span class="title">listInsertNode</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, listNode *old_node, <span class="keyword">void</span> *value, <span class="keyword">int</span> after)</span> </span>&#123; <span class="comment">//O(1)将值插入指定节点后,listNode一定是存在的.</span></span><br><span class="line">    listNode *node; <span class="comment">//申请节点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((node = zmalloc(<span class="keyword">sizeof</span>(*node))) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    node-&gt;value = value;<span class="comment">//节点赋值</span></span><br><span class="line">    <span class="keyword">if</span> (after) &#123;</span><br><span class="line">        <span class="comment">//old_node之后插入</span></span><br><span class="line">        node-&gt;prev = old_node; <span class="comment">//</span></span><br><span class="line">        node-&gt;next = old_node-&gt;next;</span><br><span class="line">        <span class="comment">//如果指定的节点是尾节点,处理尾指针</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">list</span>-&gt;tail == old_node) &#123;</span><br><span class="line">            <span class="built_in">list</span>-&gt;tail = node; <span class="comment">//</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//插入到old_node之前</span></span><br><span class="line">        node-&gt;next = old_node;</span><br><span class="line">        node-&gt;prev = old_node-&gt;prev;</span><br><span class="line">        <span class="comment">//如果指定的节点是头节点,处理头指针</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">list</span>-&gt;head == old_node) &#123;</span><br><span class="line">            <span class="built_in">list</span>-&gt;head = node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果插入的节点不是头指针</span></span><br><span class="line">    <span class="keyword">if</span> (node-&gt;prev != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        node-&gt;prev-&gt;next = node;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="comment">//如果插入的节点不是尾指针</span></span><br><span class="line">    <span class="keyword">if</span> (node-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        node-&gt;next-&gt;prev = node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">list</span>-&gt;len++;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="修改链表"><a href="#修改链表" class="headerlink" title="修改链表"></a>修改链表</h3><p>将链表的尾节点移动至头结点,可用于将链表反转<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">listRotate</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>)</span> </span>&#123; <span class="comment">//O(1)</span></span><br><span class="line">    listNode *tail = <span class="built_in">list</span>-&gt;tail; <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (listLength(<span class="built_in">list</span>) &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Detach current tail */</span></span><br><span class="line">    <span class="comment">//将尾节点的前驱更新为尾节点</span></span><br><span class="line">    <span class="built_in">list</span>-&gt;tail = tail-&gt;prev;</span><br><span class="line">    <span class="built_in">list</span>-&gt;tail-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">/* Move it as head */</span></span><br><span class="line">    <span class="comment">//将尾节点插入头节点前</span></span><br><span class="line">    <span class="built_in">list</span>-&gt;head-&gt;prev = tail;</span><br><span class="line">    tail-&gt;prev = <span class="literal">NULL</span>;</span><br><span class="line">    tail-&gt;next = <span class="built_in">list</span>-&gt;head;</span><br><span class="line">    <span class="built_in">list</span>-&gt;head = tail;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">listDelNode</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, listNode *node)</span> <span class="comment">//O(1)删除节点</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//处理前驱节点指针</span></span><br><span class="line">    <span class="keyword">if</span> (node-&gt;prev) <span class="comment">//不是头结点</span></span><br><span class="line">        node-&gt;prev-&gt;next = node-&gt;next;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">list</span>-&gt;head = node-&gt;next;</span><br><span class="line">         <span class="comment">//处理后继节点指针</span></span><br><span class="line">    <span class="keyword">if</span> (node-&gt;next) <span class="comment">//不是尾节点</span></span><br><span class="line">        node-&gt;next-&gt;prev = node-&gt;prev;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">list</span>-&gt;tail = node-&gt;prev;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">list</span>-&gt;<span class="built_in">free</span>) <span class="built_in">list</span>-&gt;<span class="built_in">free</span>(node-&gt;value); <span class="comment">//释放节点值</span></span><br><span class="line">    zfree(node); <span class="comment">//删除节点</span></span><br><span class="line">    <span class="built_in">list</span>-&gt;len--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><p>搜索链表节点返回匹配给定键值的第一个节点.<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">listNode *<span class="title">listSearchKey</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, <span class="keyword">void</span> *key)</span> <span class="comment">//O(n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    listIter iter;</span><br><span class="line">    listNode *node;</span><br><span class="line"></span><br><span class="line">    listRewind(<span class="built_in">list</span>, &amp;iter); <span class="comment">//迭代器,指向头结点开始搜索</span></span><br><span class="line">    <span class="keyword">while</span>((node = listNext(&amp;iter)) != <span class="literal">NULL</span>) &#123; <span class="comment">//迭代器</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">list</span>-&gt;match) &#123; <span class="comment">//是否存在匹配的函数</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">list</span>-&gt;match(node-&gt;value, key)) &#123;</span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (key == node-&gt;value) &#123;</span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">//不存在返回为空</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>返回指定索引的值,正数从链表头部为0开始,负数从链表的尾端开始-1即尾部<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">listNode *<span class="title">listIndex</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, <span class="keyword">long</span> index)</span> </span>&#123; <span class="comment">//O(n)</span></span><br><span class="line">    listNode *n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span>) &#123; <span class="comment">//从尾节点开始</span></span><br><span class="line">        index = (-index)<span class="number">-1</span>;</span><br><span class="line">        n = <span class="built_in">list</span>-&gt;tail;</span><br><span class="line">        <span class="keyword">while</span>(index-- &amp;&amp; n) n = n-&gt;prev;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        n = <span class="built_in">list</span>-&gt;head;</span><br><span class="line">        <span class="keyword">while</span>(index-- &amp;&amp; n) n = n-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="合并链表"><a href="#合并链表" class="headerlink" title="合并链表"></a>合并链表</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">listJoin</span><span class="params">(<span class="built_in">list</span> *l, <span class="built_in">list</span> *o)</span> </span>&#123; <span class="comment">//将</span></span><br><span class="line">    <span class="keyword">if</span> (o-&gt;head) <span class="comment">//将O添加到l之后</span></span><br><span class="line">        o-&gt;head-&gt;prev = l-&gt;tail;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (l-&gt;tail) <span class="comment">//l不为空</span></span><br><span class="line">        l-&gt;tail-&gt;next = o-&gt;head;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        l-&gt;head = o-&gt;head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (o-&gt;tail) l-&gt;tail = o-&gt;tail; <span class="comment">//O不为空</span></span><br><span class="line">    l-&gt;len += o-&gt;len;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Setup other as an empty list. O为空节点*/</span></span><br><span class="line">    o-&gt;head = o-&gt;tail = <span class="literal">NULL</span>;</span><br><span class="line">    o-&gt;len = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="迭代器的相关操作"><a href="#迭代器的相关操作" class="headerlink" title="迭代器的相关操作"></a>迭代器的相关操作</h2><h3 id="创建迭代器"><a href="#创建迭代器" class="headerlink" title="创建迭代器"></a>创建迭代器</h3><p>创建链表的迭代器<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">listIter *<span class="title">listGetIterator</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, <span class="keyword">int</span> direction)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    listIter *iter; <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((iter = zmalloc(<span class="keyword">sizeof</span>(*iter))) == <span class="literal">NULL</span>)  <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">//创建</span></span><br><span class="line">    <span class="keyword">if</span> (direction == AL_START_HEAD) <span class="comment">//根据迭代器的方向，将迭代器的指针指向表头</span></span><br><span class="line">        iter-&gt;next = <span class="built_in">list</span>-&gt;head;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">//或者表尾</span></span><br><span class="line">        iter-&gt;next = <span class="built_in">list</span>-&gt;tail;</span><br><span class="line">    iter-&gt;direction = direction; <span class="comment">//记录方向</span></span><br><span class="line">    <span class="keyword">return</span> iter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="修改迭代器"><a href="#修改迭代器" class="headerlink" title="修改迭代器"></a>修改迭代器</h3><p>将迭代器指向链表头,并正向<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">listRewind</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, listIter *li)</span> </span>&#123; <span class="comment">//O(1)</span></span><br><span class="line">    li-&gt;next = <span class="built_in">list</span>-&gt;head;</span><br><span class="line">    li-&gt;direction = AL_START_HEAD;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>将迭代器指向链表为,并逆向<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">listRewindTail</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, listIter *li)</span> </span>&#123; <span class="comment">// O(1)</span></span><br><span class="line">    li-&gt;next = <span class="built_in">list</span>-&gt;tail;</span><br><span class="line">    li-&gt;direction = AL_START_TAIL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="迭代器执行"><a href="#迭代器执行" class="headerlink" title="迭代器执行"></a>迭代器执行</h3><p>返回迭代器指向的元素,并移动迭代器<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">listNode *<span class="title">listNext</span><span class="params">(listIter *iter)</span> <span class="comment">//O(1)返回迭代器指向的元素,并移动迭代器</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    listNode *current = iter-&gt;next; <span class="comment">//指向iter指向的节点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (current != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (iter-&gt;direction == AL_START_HEAD)</span><br><span class="line">            iter-&gt;next = current-&gt;next;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            iter-&gt;next = current-&gt;prev;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> current; <span class="comment">//返回当前迭代器指向的节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="使用迭代器操作链表"><a href="#使用迭代器操作链表" class="headerlink" title="使用迭代器操作链表"></a>使用迭代器操作链表</h2><h3 id="使用迭代器拷贝链表"><a href="#使用迭代器拷贝链表" class="headerlink" title="使用迭代器拷贝链表"></a>使用迭代器拷贝链表</h3><p> 复制整个列表。在内存不足返回NULL。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">list</span> *<span class="title">listDup</span><span class="params">(<span class="built_in">list</span> *orig)</span>  <span class="comment">//拷贝链表</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">list</span> *copy; <span class="comment">//链表指针</span></span><br><span class="line">    listIter iter; <span class="comment">//迭代器</span></span><br><span class="line">    listNode *node; <span class="comment">//节点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((copy = listCreate()) == <span class="literal">NULL</span>) <span class="comment">//创建链表</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="comment">//复制操作</span></span><br><span class="line">    copy-&gt;dup = orig-&gt;dup; </span><br><span class="line">    copy-&gt;<span class="built_in">free</span> = orig-&gt;<span class="built_in">free</span>;</span><br><span class="line">    copy-&gt;match = orig-&gt;match;</span><br><span class="line">    listRewind(orig, &amp;iter); <span class="comment">//将迭代器指向链表头</span></span><br><span class="line">    <span class="keyword">while</span>((node = listNext(&amp;iter)) != <span class="literal">NULL</span>) &#123; <span class="comment">//迭代器指为空</span></span><br><span class="line">        <span class="keyword">void</span> *value;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (copy-&gt;dup) &#123; <span class="comment">//是否有复制的函数</span></span><br><span class="line">            value = copy-&gt;dup(node-&gt;value);<span class="comment">//复制节点的值,返回复制节点的值</span></span><br><span class="line">            <span class="keyword">if</span> (value == <span class="literal">NULL</span>) &#123;<span class="comment">//值为空,复制失败</span></span><br><span class="line">                listRelease(copy); <span class="comment">//清除链表</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            value = node-&gt;value; <span class="comment">//没有复制的函数,赋值操作</span></span><br><span class="line">        <span class="keyword">if</span> (listAddNodeTail(copy, value) == <span class="literal">NULL</span>) &#123; <span class="comment">//将值添加到尾端</span></span><br><span class="line">            listRelease(copy);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> copy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;redis &lt;a href=&quot;https://github.com/antirez/redis/blob/5.0/src/adlist.h&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/antirez/redis/blob/5.0/src/adlist.h&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://github.com/antirez/redis/blob/5.0/src/adlist.c&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/antirez/redis/blob/5.0/src/adlist.c&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;结构体的定义&quot;&gt;&lt;a href=&quot;#结构体的定义&quot; class=&quot;headerlink&quot; title=&quot;结构体的定义&quot;&gt;&lt;/a&gt;结构体的定义&lt;/h2&gt;&lt;p&gt;结构体的实现,双向链表的相关定义于&lt;code&gt;adlist.h&lt;/code&gt;中&lt;br&gt;节点:&lt;br&gt;&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;listNode&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;listNode&lt;/span&gt; *&lt;span class=&quot;title&quot;&gt;prev&lt;/span&gt;;&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;//前一个节点&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;listNode&lt;/span&gt; *&lt;span class=&quot;title&quot;&gt;next&lt;/span&gt;;&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;//后一个节点&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *value; &lt;span class=&quot;comment&quot;&gt;//节点的值&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125; listNode;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="basic" scheme="https://vaniot-s.github.io/categories/basic/"/>
    
    
      <category term="redis" scheme="https://vaniot-s.github.io/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>TCP与UDP</title>
    <link href="https://vaniot-s.github.io/2018/11/05/TCP%E4%B8%8EUDP/"/>
    <id>https://vaniot-s.github.io/2018/11/05/TCP与UDP/</id>
    <published>2018-11-05T00:27:30.000Z</published>
    <updated>2021-05-06T21:05:19.536Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>计算机内部通信时，可以使用管道，内存共享，信号量，消息队列等，在计算机间的通信时，在运输层使用协议的端口号来标识，计算机的一个进程，即；<b>IP地址+协议+端口号</b>标识网络中的一个进程，也被称之为<code>套接字</code>。<br><a id="more"></a></p><h2 id="端口号"><a href="#端口号" class="headerlink" title="端口号"></a>端口号</h2><p>TCP中使用16位的端口号用于标识端口,故端口号的范围是:<code>0~65535</code>，共$2^{16}$个端口。</p><h3 id="端口号分类"><a href="#端口号分类" class="headerlink" title="端口号分类"></a>端口号分类</h3><h4 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h4><ul><li>熟知端口号：<br>取值范围:0~1023</li></ul><table><thead><tr><th>应用程序</th><th>FTP</th><th>TELENT</th><th>SMTP</th><th>DNS</th><th>TFTP</th><th>HTTP</th><th>HTTP</th><th>SNMP</th></tr></thead><tbody><tr><td>端口号</td><td>21</td><td>23</td><td>25</td><td>53</td><td>69</td><td>80</td><td>443</td><td>161</td></tr></tbody></table><ul><li>登记端口号：<br>取值范围：1024~49151</li></ul><h4 id="客户端端口号"><a href="#客户端端口号" class="headerlink" title="客户端端口号"></a>客户端端口号</h4><p>取值范围:49152~6535，在客户端运行时才选择。</p><blockquote><p>使用<code>cat /et/services</code>可查看所有知名服务使用的端口号。</p></blockquote><h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><h2 id="TCP报文-segment"><a href="#TCP报文-segment" class="headerlink" title="TCP报文(segment)"></a>TCP报文(segment)</h2><p> TCP是面向字节流传送的数据单元是报文段的协议。<br> TCP报文:<br> <table><br> <tr><br> <th>TCP首部</th><br> <th>TCP数据</th><br> </tr><br> </table><br> 报文首部:</p><p><img src="https://raw.githubusercontent.com/vaniot-s/picture/master/tcp/tcp%E6%8A%A5%E6%96%87.png" alt="tcp报文首部"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;计算机内部通信时，可以使用管道，内存共享，信号量，消息队列等，在计算机间的通信时，在运输层使用协议的端口号来标识，计算机的一个进程，即；&lt;b&gt;IP地址+协议+端口号&lt;/b&gt;标识网络中的一个进程，也被称之为&lt;code&gt;套接字&lt;/code&gt;。&lt;br&gt;
    
    </summary>
    
      <category term="basic" scheme="https://vaniot-s.github.io/categories/basic/"/>
    
    
      <category term="计算机网路，传输层" scheme="https://vaniot-s.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E8%B7%AF%EF%BC%8C%E4%BC%A0%E8%BE%93%E5%B1%82/"/>
    
  </entry>
  
  <entry>
    <title>golang笔记</title>
    <link href="https://vaniot-s.github.io/2018/10/31/golang%E7%AC%94%E8%AE%B0/"/>
    <id>https://vaniot-s.github.io/2018/10/31/golang笔记/</id>
    <published>2018-10-31T01:36:30.000Z</published>
    <updated>2021-05-06T21:05:19.536Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="Go环境变量"><a href="#Go环境变量" class="headerlink" title="Go环境变量"></a>Go环境变量</h2><h3 id="GOROOT"><a href="#GOROOT" class="headerlink" title="GOROOT"></a>GOROOT</h3><p>  golang当前的安装目录</p><h3 id="GOPATH"><a href="#GOPATH" class="headerlink" title="GOPATH"></a>GOPATH</h3><p>  golang工作区的集合，放置golang源码文件的目录，包含以下三个目录<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">├── bin  //编译后的可执行文件</span><br><span class="line">├── pkg  //存放go install命令安装后的代码包的归档文件</span><br><span class="line">└── src  //源码存放，命令源码文件并不一定必须放在 src 文件夹</span><br></pre></td></tr></table></figure></p><h3 id="GOBIN"><a href="#GOBIN" class="headerlink" title="GOBIN"></a>GOBIN</h3><p>  指向编译后的可执行文件，上述的bin目录</p><h3 id="GOOS-和-GOARCH"><a href="#GOOS-和-GOARCH" class="headerlink" title="GOOS 和 GOARCH"></a>GOOS 和 GOARCH</h3><p>  两个环境变量是不用我们设置的，系统就默认的。GOOS 是 Go 所在的操作系统类型，GOARCH 是 Go 所在的计算架构。<br>  <a id="more"></a></p><h2 id="Go命令基础"><a href="#Go命令基础" class="headerlink" title="Go命令基础"></a>Go命令基础</h2><h3 id="go-run"><a href="#go-run" class="headerlink" title="go run"></a>go run</h3><p><code>go run</code>用于运行命令源码文件，只接受一个<b>命令源码文件</b><code>，go run</code>包含了<code>go build</code>的编译过程，可以接受<code>go build</code>的所有命令参数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go run [build flags] [-exec xprog] gofiles... [arguments...]</span><br></pre></td></tr></table></figure></p><h3 id="go-build"><a href="#go-build" class="headerlink" title="go build"></a>go build</h3><p><code>go build</code>编译制定的源码文件或代码包及其依赖包<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go build [-o output] [-i] [build flags] [packages]</span><br></pre></td></tr></table></figure></p><p>参数<code>[-i]</code>:</p><ul><li><code>-a</code>对所有的相关代码包进行重新构建</li><li><code>-n</code>打印编译时用到的命令，不执行</li><li><code>-p n</code>指定编译时执行过程中的并行数量，默认为CPU的逻辑数量</li><li><code>-race</code>开启竞态条件检测</li><li><code>-work</code>打印编译时生成的临时工作目录的路径，编译结束后保留(默认删除)</li><li><code>-x</code>打印编译期间用到的其他的命令，并将执行这些命令</li><li><code>-asmflags</code></li><li><code>-buildmode</code> 用于制定编译的模式<code>-buildmode=default</code>(使用默认的设置)，用于控制编译完成后生成静态链接库（即.a文件，也就是我们之前说的归档文件）、动态链接库（即.so文                   。件）或/和可执行文件。</li><li><code>gcflags</code>用于制定需要传递给<code>go tool compile</code>的命令的标记文件</li></ul><h3 id="go-install"><a href="#go-install" class="headerlink" title="go install"></a>go install</h3><p>  编译并安装制定的代码包及它们的依赖包，比<code>go build</code>多一步，将编译后的结果文件安装到指定的目录</p><h3 id="go-get"><a href="#go-get" class="headerlink" title="go get"></a>go get</h3><p>  将从互联网下载或更行制定的代码及其依赖包，并将编译和安装<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get [-d] [-f] [-fix] [-insecure] [-t] [-u] [build flags] [packages]</span><br></pre></td></tr></table></figure></p><ul><li><code>-d</code> 命令只会执行下载操作，而不会执行安装动作</li><li><code>-f</code> 与<code>-u</code>一同执行时才有效，让命令程序忽略已下载代码包的导入路径的检查。</li><li><code>-fix</code> 下载代码包后先执行修正操作，在进行编译和安装。</li><li><code>-insecure</code>允许使用非安全的<code>scheme</code>（如http）去下载指定的代码包。</li><li><code>-t</code> 下载安装指定的代码包中的测试源码文件中的依赖的代码包</li><li><code>-u</code> 利用网络更新已有代码包及其依赖包。</li><li><code>-x</code> 查看<code>go get</code>执行过程中使用的所有命令</li></ul><h3 id="go-list"><a href="#go-list" class="headerlink" title="go list"></a>go list</h3><p>  列出指定的代码包的信息<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go list [-e] [-f format] [-json] [build flags] [packages]</span><br></pre></td></tr></table></figure></p><h3 id="go-test"><a href="#go-test" class="headerlink" title="go test"></a>go test</h3>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go test [build/test flags] [packages] [build/test flags &amp; test binary flags]</span><br></pre></td></tr></table></figure><ul><li><code>-c</code>生成用于测试的可执行文件，不执行</li><li><code>-i</code>安装运行测试所需要的依赖包，不编译测试运行测试代码</li><li><code>-o</code>指定用于运行测试可执行文件的名称，不影响测试代码的运行</li></ul><h3 id="go-tool"><a href="#go-tool" class="headerlink" title="go tool"></a>go tool</h3>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go tool [-n] command [args...]</span><br></pre></td></tr></table></figure><ul><li>go tool pprof命令来交互式的访问概要文件的内容。会分析指定的概要文件，并会提供高可读性的输出信息。</li><li>go tool cgo这个工具可以使我们创建能够调用C语言代码的Go语言源码文件。</li></ul><h3 id="go-fmt"><a href="#go-fmt" class="headerlink" title="go fmt"></a>go fmt</h3>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go fmt [-n] [-x] [packages]</span><br></pre></td></tr></table></figure><ul><li><code>-n</code>打印编译期间所用到的其它命令，但是不执行它们。</li><li><code>-x</code>可以看到<code>go get</code>命令执行过程中所使用的所有命令。</li></ul><h2 id="go-clean"><a href="#go-clean" class="headerlink" title="go clean"></a>go clean</h2><p>删除执行其他命令时产生的文件和目录(go build和go test)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go clean [-i] [-r] [-n] [-x] [build flags] [packages]</span><br></pre></td></tr></table></figure></p><ul><li><code>- r</code>当前代码包的所有依赖包及<code>go build</code>和<code>go test</code>相关</li><li><code>-i</code>除安装当前代码包时所产生的结果文件</li></ul><h2 id="go-doc"><a href="#go-doc" class="headerlink" title="go doc"></a>go doc</h2><p>可以打印附于Go语言程序实体上的文档。我们可以通过把程序实体的标识符作为该命令的参数来达到查看其文档的目的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go doc [-u] [-c] [package|[package.]symbol[.method]]</span><br></pre></td></tr></table></figure></p><ul><li><code>-c</code>加入此标记后会使go doc命令区分参数中字母的大小写。</li><li><code>-cmd</code>打印出main包中的可导出的程序实体（其名称的首字母大写）的文档。</li><li><code>-u</code>打印出不可导出的程序实体（其名称的首字母小写）的文档。</li><li><code>godoc</code>用于展示指定代码包的文档。在Go语言的1.5版本以后，它是一个内置的标准命令。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">godoc -http=:6060标记-http的值:6060表示启动的Web服务器使用本机的6060端口。</span><br></pre></td></tr></table></figure></li></ul><h2 id="go-generate"><a href="#go-generate" class="headerlink" title="go generate"></a>go generate</h2><p><code>go generate</code>可以用来自动自成Go代码的命令。</p><h1 id="go语言特性"><a href="#go语言特性" class="headerlink" title="go语言特性"></a>go语言特性</h1>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Go环境变量&quot;&gt;&lt;a href=&quot;#Go环境变量&quot; class=&quot;headerlink&quot; title=&quot;Go环境变量&quot;&gt;&lt;/a&gt;Go环境变量&lt;/h2&gt;&lt;h3 id=&quot;GOROOT&quot;&gt;&lt;a href=&quot;#GOROOT&quot; class=&quot;headerlink&quot; title=&quot;GOROOT&quot;&gt;&lt;/a&gt;GOROOT&lt;/h3&gt;&lt;p&gt;  golang当前的安装目录&lt;/p&gt;
&lt;h3 id=&quot;GOPATH&quot;&gt;&lt;a href=&quot;#GOPATH&quot; class=&quot;headerlink&quot; title=&quot;GOPATH&quot;&gt;&lt;/a&gt;GOPATH&lt;/h3&gt;&lt;p&gt;  golang工作区的集合，放置golang源码文件的目录，包含以下三个目录&lt;br&gt;  &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;├── bin  //编译后的可执行文件&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;├── pkg  //存放go install命令安装后的代码包的归档文件&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;└── src  //源码存放，命令源码文件并不一定必须放在 src 文件夹&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;GOBIN&quot;&gt;&lt;a href=&quot;#GOBIN&quot; class=&quot;headerlink&quot; title=&quot;GOBIN&quot;&gt;&lt;/a&gt;GOBIN&lt;/h3&gt;&lt;p&gt;  指向编译后的可执行文件，上述的bin目录&lt;/p&gt;
&lt;h3 id=&quot;GOOS-和-GOARCH&quot;&gt;&lt;a href=&quot;#GOOS-和-GOARCH&quot; class=&quot;headerlink&quot; title=&quot;GOOS 和 GOARCH&quot;&gt;&lt;/a&gt;GOOS 和 GOARCH&lt;/h3&gt;&lt;p&gt;  两个环境变量是不用我们设置的，系统就默认的。GOOS 是 Go 所在的操作系统类型，GOARCH 是 Go 所在的计算架构。&lt;br&gt;
    
    </summary>
    
      <category term="web" scheme="https://vaniot-s.github.io/categories/web/"/>
    
    
      <category term="golang" scheme="https://vaniot-s.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>RESTful架构</title>
    <link href="https://vaniot-s.github.io/2018/10/31/RESTful%E6%9E%B6%E6%9E%84/"/>
    <id>https://vaniot-s.github.io/2018/10/31/RESTful架构/</id>
    <published>2018-10-31T01:00:43.000Z</published>
    <updated>2021-05-06T21:05:19.536Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>HTTP协议本身是一种面向资源的应用层协议，但对HTTP协议的使用实际上存在着两种不同的方式：一种是RESTful的，它把HTTP当成应用层协议，比较忠实地遵守了HTTP协议的各种规定；另一种是SOA的，它并没有完全把HTTP当成应用层协议，而是把HTTP协议作为了传输层协议，然后在HTTP之上建立了自己的应用层协议.<br>RESTful(Representational State Transfer 表述性状态转移):对基于HTTP的应用提供了一种设计原则,即:<br><img src="https://github.com/vaniot-s/picture/blob/master/RESTful/restful.png?raw=true" alt="RESTFul"></p><h2 id="RESTFul定义的URL"><a href="#RESTFul定义的URL" class="headerlink" title="RESTFul定义的URL"></a>RESTFul定义的URL</h2><p>RESTful架构又被称作为“面向资源开发”,将任何可命名的概念视为资源,资源可以是实体或抽象的概念，<code>URL</code>的命名以<code>名词为核心</code>.URL表达了被操作资源的位置,不使用动词,并要注意单复数区分.<br><a id="more"></a></p><h3 id="RESTful的URL设计"><a href="#RESTful的URL设计" class="headerlink" title="RESTful的URL设计"></a>RESTful的URL设计</h3><ul><li>使用<code>—</code>或<code>-</code>连接名词提升易读性，如:<code>http://www.example.com/restful-archiecture</code></li><li><p>使用<code>/</code>表示资源的层级关系,如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//访问文章列表</span><br><span class="line">http://www.example.com/posts</span><br><span class="line">//某篇文章</span><br><span class="line">http://example.com/posts/&#123;post&#125;</span><br><span class="line">//某篇文章下的评论列表</span><br><span class="line">http://www.example.com/&#123;posts/post&#125;/comments</span><br></pre></td></tr></table></figure></li><li><p>使用<code>，</code>或者<code>;</code>表示同级资源的关系，如:<code>http://www.example.com/gone-with-wind;Jane-Eyre</code></p></li><li>使用<code>?</code>过滤资源，使用’&amp;’分割参数<code>http://www.example.com/books?category=science</code></li><li>在URI中避免出现文件扩展名(例如.php,.aspx 和.jsp)。<h2 id="HTTP动词"><a href="#HTTP动词" class="headerlink" title="HTTP动词"></a>HTTP动词</h2>RESTful架构遵循统一的接口原则，包含一组受限的预定义的操作，所有的资源通过相同的接口进行资源访问,使用HTTP方法,并遵守其语义.</li></ul><table><thead><tr><th style="text-align:left">动作</th><th style="text-align:left">操作</th></tr></thead><tbody><tr><td style="text-align:left">GET(SELECT)</td><td style="text-align:left">从服务器检索特定资源(或列表)</td></tr><tr><td style="text-align:left">POST(CREATE)</td><td style="text-align:left">在服务器上创建一个新的资源</td></tr><tr><td style="text-align:left">PUT(UPDATE)</td><td style="text-align:left">更新服务器上的整个资源</td></tr><tr><td style="text-align:left">PATCH(UPDATE)</td><td style="text-align:left">更新服务器上的部分资源</td></tr><tr><td style="text-align:left">DELETE(DELETE)</td><td style="text-align:left">从服务器上删除资源</td></tr><tr><td style="text-align:left">OPTION(OPTION)</td><td style="text-align:left">跨域访问预请求</td></tr></tbody></table><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><h4 id="GET"><a href="#GET" class="headerlink" title="GET"></a>GET</h4><ul><li>安全且幂等</li><li>语义:法请求指定的资源</li></ul><table><thead><tr><th>状态码</th><th>状态含义</th></tr></thead><tbody><tr><td>200（OK）</td><td>表示已在响应中发出</td></tr><tr><td>204（无内容）</td><td>资源有空表示</td></tr><tr><td>301（Moved Permanently）</td><td>资源的URI已被更新</td></tr><tr><td>303（See Other）</td><td>其他（如，负载均衡）</td></tr><tr><td>304（not modified）</td><td>资源未更改（缓存）</td></tr><tr><td>400 （bad request）</td><td>指代坏请求（如，参数错误）</td></tr><tr><td>404 （not found）</td><td>资源不存在</td></tr><tr><td>406 （not acceptable）</td><td>服务端不支持所需表示</td></tr><tr><td>500 （internal server error）</td><td>通用错误响应</td></tr><tr><td>503 （Service Unavailable）</td><td>服务端当前无法处理请求</td></tr></tbody></table><p><a href="https://tools.ietf.org/html/rfc7231#section-4.3.1" target="_blank" rel="noopener">GET更多…</a></p><h4 id="POST"><a href="#POST" class="headerlink" title="POST"></a>POST</h4><ul><li>不安全且不幂等</li><li>语义:发送数据给服务器,创建资源. </li></ul><table><thead><tr><th>状态码</th><th>状态含义</th></tr></thead><tbody><tr><td>200（OK）</td><td>如果现有资源已被更改</td></tr><tr><td>201（created）</td><td>如果新资源被创建</td></tr><tr><td>202（accepted）</td><td>已接受处理请求但尚未完成（异步处理）</td></tr><tr><td>301（Moved Permanently）</td><td>资源的URI被更新</td></tr><tr><td>303（See Other）</td><td>其他（如，负载均衡）</td></tr><tr><td>400（bad request）</td><td>指代坏请求</td></tr><tr><td>404 （not found）</td><td>资源不存在</td></tr><tr><td>406 （not acceptable）</td><td>服务端不支持所需表示</td></tr><tr><td>409 （conflict）</td><td>通用冲突</td></tr><tr><td>412 （Precondition Failed）</td><td>前置条件失败（如执行条件更新时的冲突）</td></tr><tr><td>415 （unsupported media type）</td><td>接受到的表示不受支持</td></tr><tr><td>500 （internal server error）</td><td>通用错误响应</td></tr><tr><td>503 （Service Unavailable）</td><td>服务当前无法处理请求</td></tr></tbody></table><p><a href="https://tools.ietf.org/html/rfc7231#section-4.3.3" target="_blank" rel="noopener">POST更多…</a></p><h4 id="PUT"><a href="#PUT" class="headerlink" title="PUT"></a>PUT</h4><ul><li>不安全但幂等</li><li>语义:用于新增资源或者使用请求中的有效负载替换目标资源的表现形式。</li></ul><table><thead><tr><th>状态码</th><th>状态含义</th></tr></thead><tbody><tr><td>200 （OK）</td><td>如果已存在资源被更改</td></tr><tr><td>301（Moved Permanently）</td><td>资源的URI已更改</td></tr><tr><td>303 （See Other）</td><td>其他（如，负载均衡）</td></tr><tr><td>400 （bad request）</td><td>指代坏请求</td></tr><tr><td>404 （not found）</td><td>资源不存在</td></tr><tr><td>406 （not acceptable）</td><td>服务端不支持所需表示</td></tr><tr><td>409 （conflict）</td><td>通用冲突</td></tr><tr><td>412 （Precondition Failed）</td><td>前置条件失败（如执行条件更新时的冲突）</td></tr><tr><td>415 （unsupported media type）</td><td>接受到的表示不受支持</td></tr><tr><td>500 （internal server error）</td><td>通用错误响应</td></tr><tr><td>503 （Service Unavailable）</td><td>服务当前无法处理请求</td></tr></tbody></table><p><a href="https://tools.ietf.org/html/rfc7231#section-4.3.4" target="_blank" rel="noopener">Put更多…</a></p><h4 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a>DELETE</h4><ul><li>不安全但幂等</li><li>语义:请求方法用于删除指定的资源。</li></ul><table><thead><tr><th>状态码</th><th>状态含义</th></tr></thead><tbody><tr><td>200 （OK）</td><td>资源已被删除</td></tr><tr><td>301 （Moved Permanently）</td><td>资源的URI已更改</td></tr><tr><td>303 （See Other）</td><td>其他，如负载均衡</td></tr><tr><td>400 （bad request）</td><td>指代坏请求</td></tr><tr><td>404 （not found）</td><td>资源不存在</td></tr><tr><td>409 （conflict）</td><td>通用冲突</td></tr><tr><td>500 （internal server error）</td><td>通用错误响应</td></tr><tr><td>503 （Service Unavailable）</td><td>服务端当前无法处理请求</td></tr></tbody></table><blockquote><p><a href="https://developer.mozilla.org/zh-CN/docs/Glossary/%E5%B9%82%E7%AD%89" target="_blank" rel="noopener">幂等</a>：指的是同样的请求被执行一次与连续执行多次的效果是一样的，服务器的状态也是一样的，幂等方法不应该具有副作用(统计用途除外）。幂等是分布式系统的一种特性,不论是SOA还是RESTful的Web API设计都应该考虑幂等性。</p></blockquote><blockquote><p>使用RestFul操作资源的例子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GET /collection #获取所有的集合列表</span><br><span class="line">POST /collection #新建一个集合</span><br><span class="line">GET /collection/:id #获取指定集合的信息</span><br><span class="line">PUT /collection/:id #更新指定集合的全部信息</span><br><span class="line">PATCH /collection/:id #更新指定集合的部分信息</span><br><span class="line">DELETE /collection/:id #删除指定的集合</span><br></pre></td></tr></table></figure></p></blockquote><h2 id="资源的表述"><a href="#资源的表述" class="headerlink" title="资源的表述"></a>资源的表述</h2><p>客户端通过HTTP获取资源的表述,如文本的表述格式可为:html,xml,json等,资源的表述包括数据和描述数据的元数据，例如，HTTP头“Content-Type” 就是这样一个元数据属性。</p><h3 id="JSON-API"><a href="#JSON-API" class="headerlink" title="JSON API"></a>JSON API</h3><p>RestFul规定URL和HTTP Method的使用,未定义body的数据格式,JSON是最主流的网络传输格式</p><h4 id="MIME类型"><a href="#MIME类型" class="headerlink" title="MIME类型"></a>MIME类型</h4><p>客户端请求头中<code>Content-Type</code>应该为<code>application/vnd.api+json</code>，并且在<code>Accept</code>中也必须包含<code>application/vnd.api+json</code>。如果指定错误服务器应该返回415或406状态码。</p><h2 id="客户端与服务端"><a href="#客户端与服务端" class="headerlink" title="客户端与服务端"></a>客户端与服务端</h2><p>  客户端获取资源的表述（资源的外在呈现)不是资源的本身，资源的的表述包含了数据的描述和数据的元数据，浏览器与服务器间通过HTTP协议协商，浏览器通过<code>Accept</code>头请求一种特定的格式表述，服务器通过<code>Content-type</code>返回给浏览器客户端资源的表述形式。<br>  <img src="https://raw.githubusercontent.com/vaniot-s/picture/master/RESTful/resourcedecrption.jpg" alt="资源表述"></p><h2 id="状态转移"><a href="#状态转移" class="headerlink" title="状态转移"></a>状态转移</h2><p>  在REST设计原则中客户端与服务端的交互是无状态(HTTP协议的特性)，客户端维护应用的状态，服务端维护资源的状态，但服务端不保存客户端状态。只有在每一次的请求中包含处理请求的信息，”会话”被客户端用作为应用状态进行跟踪，在服务端的超媒体的指引下发生变迁。服务端通过超媒体告诉客户端当前状态有哪些后续状态可以进入。 </p><blockquote><p>ps</p><ul><li>违反无状态通信原则的设计,如:利用Cookie跟踪某个服务端会话状态.</li><li>超媒体:把一个个把资源链接起来.</li></ul></blockquote><h2 id="认证机制"><a href="#认证机制" class="headerlink" title="认证机制"></a>认证机制</h2><p>  认证机制的引入用于解决，RESTful的服务无状态，认证机制用于确定访问资源的用户(权限机制用于确定用户是否可以使用，修改，删除或创建资源，常与业务逻辑绑定)，</p><p>### </p><blockquote><p>参考资料<br> 1.<a href="http://jsonapi.org/format/" target="_blank" rel="noopener">json</a><br> 2.<a href="https://insights.thoughtworks.cn/api-restful/" target="_blank" rel="noopener">细说API – 重新认识RESTful</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;HTTP协议本身是一种面向资源的应用层协议，但对HTTP协议的使用实际上存在着两种不同的方式：一种是RESTful的，它把HTTP当成应用层协议，比较忠实地遵守了HTTP协议的各种规定；另一种是SOA的，它并没有完全把HTTP当成应用层协议，而是把HTTP协议作为了传输层协议，然后在HTTP之上建立了自己的应用层协议.&lt;br&gt;RESTful(Representational State Transfer 表述性状态转移):对基于HTTP的应用提供了一种设计原则,即:&lt;br&gt;&lt;img src=&quot;https://github.com/vaniot-s/picture/blob/master/RESTful/restful.png?raw=true&quot; alt=&quot;RESTFul&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;RESTFul定义的URL&quot;&gt;&lt;a href=&quot;#RESTFul定义的URL&quot; class=&quot;headerlink&quot; title=&quot;RESTFul定义的URL&quot;&gt;&lt;/a&gt;RESTFul定义的URL&lt;/h2&gt;&lt;p&gt;RESTful架构又被称作为“面向资源开发”,将任何可命名的概念视为资源,资源可以是实体或抽象的概念，&lt;code&gt;URL&lt;/code&gt;的命名以&lt;code&gt;名词为核心&lt;/code&gt;.URL表达了被操作资源的位置,不使用动词,并要注意单复数区分.&lt;br&gt;
    
    </summary>
    
      <category term="web" scheme="https://vaniot-s.github.io/categories/web/"/>
    
    
      <category term="RESTFUL" scheme="https://vaniot-s.github.io/tags/RESTFUL/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络</title>
    <link href="https://vaniot-s.github.io/2018/10/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    <id>https://vaniot-s.github.io/2018/10/30/计算机网络/</id>
    <published>2018-10-30T09:53:51.000Z</published>
    <updated>2021-05-06T21:05:19.536Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h2><h3 id="地址的分类"><a href="#地址的分类" class="headerlink" title="地址的分类"></a>地址的分类</h3><p>IP(Internet Protocol国际互联网协议)的长度为32为(bit),分为4段，常用十进制数字表示，每段数字的范围是1～254，一个4字节的IP地址划分为两个部分用于标明网络端和标明具体的节点,分别对应两个ID(标识码):网络ID和主机ID，同一物理网络上的主机用相同的网络ID。<br><a id="more"></a></p><h3 id="五类IP地址"><a href="#五类IP地址" class="headerlink" title="五类IP地址"></a>五类IP地址</h3><h4 id="A类"><a href="#A类" class="headerlink" title="A类"></a>A类</h4><p>  A类IP地址有1个字节的网络地址和3个字节的主机地址组成，网络地址的最高位(二进制)必须为”0”(第一段数字的范围[1-126]),地址的范围从1.0.0.1~126.255.255.254可用的A类网络有126个，每个网络可容纳16777214个主机</p><blockquote><p>计算:</p></blockquote><ul><li>网段：首位为0,故网段为$2^{7}=128$扣除两个保留地址：二进制全为0(做网络号)和二进制全为1(做广播号)，故网络段位[1-126]。</li><li>主机数计算: 主机数$2^{24}-2=16777214$(扣除两个保留地址)。</li></ul><h4 id="B类"><a href="#B类" class="headerlink" title="B类"></a>B类</h4><p>  B类地址有2个字节的网路地址和2个字节的主机地址组成，网络地址的最高位(二进制)必须为“10”(第一段数字的范围[128-191]),地址范围从128.0.0.0~191.255.255.255，可用的B类网络有16382个，每个网络能容纳6万多个主机 。 </p><h4 id="C类"><a href="#C类" class="headerlink" title="C类"></a>C类</h4><p>  C类地址由3个字节的网络地址,和一个字节的主机地”组成，网络地址的最高位(二进制)必须是”110“,地址范围应该是：192.0.0.1~223.255.255.254,C类网络可以有2097150个网段,每个网络能容纳254个主机。</p><h3 id="ip地址的计算"><a href="#ip地址的计算" class="headerlink" title="ip地址的计算"></a>ip地址的计算</h3><p>通过IP地址和子网掩码计算如下地址：</p><ul><li>网络地址</li><li>广播地址</li><li>地址范围</li><li>本网的主机数量<blockquote><p>example</p></blockquote></li></ul><p>IP地址:192.168.100.5,子网掩码:255.255.255.0<br>网络地址–换算为二进制相与运算的结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">192.168.100.5(C类)  二进制:11000000.10101000.01100100.00000101</span><br><span class="line">255.255.255.0  二进制:11111111.11111111.11111111.00000000</span><br><span class="line">与运算(见0为0，全为1为1:11000000.10101000.01100100.00000000 </span><br><span class="line">故网络地址为:192.168.100.0</span><br></pre></td></tr></table></figure></p><p>广播地址–将网络地址的主机地址变为全1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">11000000.10101000.01100100.00000000 </span><br><span class="line">11000000.10101000.01100100.11111111</span><br><span class="line">故广播地址：192.168.100.255</span><br></pre></td></tr></table></figure></p><p>地址范围(本网段内的所有主机)–网络地址+1到广播地址-1<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">网络范围:192.168.100.1-192.168.100.254</span><br></pre></td></tr></table></figure></p><p>主机数量– $2^{二进制主机位数}-2$ (减2不包括网络地址和广播地址):$2^{8}-2=254$</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;IP地址&quot;&gt;&lt;a href=&quot;#IP地址&quot; class=&quot;headerlink&quot; title=&quot;IP地址&quot;&gt;&lt;/a&gt;IP地址&lt;/h2&gt;&lt;h3 id=&quot;地址的分类&quot;&gt;&lt;a href=&quot;#地址的分类&quot; class=&quot;headerlink&quot; title=&quot;地址的分类&quot;&gt;&lt;/a&gt;地址的分类&lt;/h3&gt;&lt;p&gt;IP(Internet Protocol国际互联网协议)的长度为32为(bit),分为4段，常用十进制数字表示，每段数字的范围是1～254，一个4字节的IP地址划分为两个部分用于标明网络端和标明具体的节点,分别对应两个ID(标识码):网络ID和主机ID，同一物理网络上的主机用相同的网络ID。&lt;br&gt;
    
    </summary>
    
      <category term="basic" scheme="https://vaniot-s.github.io/categories/basic/"/>
    
    
      <category term="network" scheme="https://vaniot-s.github.io/tags/network/"/>
    
  </entry>
  
  <entry>
    <title>docker实践</title>
    <link href="https://vaniot-s.github.io/2018/10/28/docker%E5%AE%9E%E8%B7%B5/"/>
    <id>https://vaniot-s.github.io/2018/10/28/docker实践/</id>
    <published>2018-10-28T20:38:55.000Z</published>
    <updated>2021-05-06T21:05:19.536Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="利用dockerfile安装monoDB"><a href="#利用dockerfile安装monoDB" class="headerlink" title="利用dockerfile安装monoDB"></a>利用dockerfile安装monoDB</h2><h3 id="dockerfile的基础结构"><a href="#dockerfile的基础结构" class="headerlink" title="dockerfile的基础结构"></a>dockerfile的基础结构</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;h2 id=&quot;利用dockerfile安装monoDB&quot;&gt;&lt;a href=&quot;#利
      
    
    </summary>
    
      <category term="tool" scheme="https://vaniot-s.github.io/categories/tool/"/>
    
    
      <category term="docker" scheme="https://vaniot-s.github.io/tags/docker/"/>
    
      <category term="git" scheme="https://vaniot-s.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>linux命令学习笔记</title>
    <link href="https://vaniot-s.github.io/2018/10/22/linux%E5%91%BD%E4%BB%A4%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://vaniot-s.github.io/2018/10/22/linux命令学习笔记/</id>
    <published>2018-10-22T23:50:54.000Z</published>
    <updated>2021-05-06T21:05:19.536Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css">]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;
      
    
    </summary>
    
    
      <category term="linux,ubuntu" scheme="https://vaniot-s.github.io/tags/linux-ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>mysql问题拾遗</title>
    <link href="https://vaniot-s.github.io/2018/09/28/mysql%E9%97%AE%E9%A2%98%E6%8B%BE%E9%81%97/"/>
    <id>https://vaniot-s.github.io/2018/09/28/mysql问题拾遗/</id>
    <published>2018-09-28T23:41:44.000Z</published>
    <updated>2021-05-06T21:05:19.536Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="ERROR-1698-28000-错误"><a href="#ERROR-1698-28000-错误" class="headerlink" title="ERROR 1698 (28000) 错误"></a>ERROR 1698 (28000) 错误</h2><p>错误详情：密码正确时用户依旧无法经如数据库中<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql -u root -p</span><br><span class="line">Enter password: </span><br><span class="line">ERROR 1698 (28000): Access denied for user 'root'@'localhost'</span><br></pre></td></tr></table></figure></p><p>错误的起因是root的plugin设置为<a href="https://dev.mysql.com/doc/dev/mysql-server/latest/auth__socket_8cc.html" target="_blank" rel="noopener">auth_socket</a>，用密码登陆的plugin应该是mysql_native_password。</p><blockquote><p>解决办法:</p></blockquote><p>在<code>/etc/mysql/mysql.conf.d/mysqld.cnf</code>这个文件里找到<code>[mysqld]</code>在该配置项下添加 <code>skip-grant-tables</code>这个配置,之后可以使用<code>mysql</code>命令直接进入而不需输入密码。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">select user, plugin from mysql.user;</span><br><span class="line">+-----------+-----------------------+</span><br><span class="line">| user      | plugin                |</span><br><span class="line">+-----------+-----------------------+</span><br><span class="line">| root      | auth_socket           |</span><br><span class="line">| mysql.sys | mysql_native_password |</span><br><span class="line">| dev       | mysql_native_password |</span><br><span class="line">+-----------+-----------------------+</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;h2 id=&quot;ERROR-1698-28000-错误&quot;&gt;&lt;a href=&quot;#ER
      
    
    </summary>
    
      <category term="web" scheme="https://vaniot-s.github.io/categories/web/"/>
    
    
      <category term="mysql" scheme="https://vaniot-s.github.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>php安全</title>
    <link href="https://vaniot-s.github.io/2018/09/26/php%E5%AE%89%E5%85%A8/"/>
    <id>https://vaniot-s.github.io/2018/09/26/php安全/</id>
    <published>2018-09-26T20:06:13.000Z</published>
    <updated>2021-05-06T21:05:19.536Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote><p>资料参考：</p></blockquote><p><a href="https://www.owasp.org/index.php/Main_Page" target="_blank" rel="noopener">开放式 Web 应用程序</a><br><a href="https://phpsecurity.readthedocs.io/en/latest/index.html" target="_blank" rel="noopener">php安全</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;blockquote&gt;
&lt;p&gt;资料参考：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;
      
    
    </summary>
    
      <category term="basic" scheme="https://vaniot-s.github.io/categories/basic/"/>
    
    
      <category term="安全" scheme="https://vaniot-s.github.io/tags/%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>shell脚本攻略</title>
    <link href="https://vaniot-s.github.io/2018/09/14/shell%E8%84%9A%E6%9C%AC%E6%94%BB%E7%95%A5/"/>
    <id>https://vaniot-s.github.io/2018/09/14/shell脚本攻略/</id>
    <published>2018-09-14T23:27:29.000Z</published>
    <updated>2021-05-06T21:05:19.536Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>todo~~</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;p&gt;todo~~&lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>基于docker+jenkins的持续集成</title>
    <link href="https://vaniot-s.github.io/2018/09/10/%E5%9F%BA%E4%BA%8Edocker-jenkins%E7%9A%84%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/"/>
    <id>https://vaniot-s.github.io/2018/09/10/基于docker-jenkins的持续集成/</id>
    <published>2018-09-10T23:28:54.000Z</published>
    <updated>2021-05-06T21:05:19.536Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="在docker中安装jenkins"><a href="#在docker中安装jenkins" class="headerlink" title="在docker中安装jenkins"></a>在docker中安装jenkins</h2><p>拉取jenkins image<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull jenkins</span><br></pre></td></tr></table></figure></p><p>Jenkins没有数据库，所有数据都是存放在文件中的，首先在本地创建Jenkins数据目录，用于保存Jenkins的数据 这个目录需要定期的备份，用于容灾（当前Jenkins容器所在节点由于不可抗因素无法使用时，可以在新机器上使用备份的数据启动新的jenkins master节点）。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir /var/jenkins</span><br><span class="line">sudo chown 1000:1000 /var/jenkins</span><br><span class="line">sudo docker run -p 8080:8080 -p 50000:50000 -v /var/jenkins:/var/jenkins_home --name my_jenkins -d jenkins</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;h2 id=&quot;在docker中安装jenkins&quot;&gt;&lt;a href=&quot;#在doc
      
    
    </summary>
    
      <category term="web" scheme="https://vaniot-s.github.io/categories/web/"/>
    
    
      <category term="docker" scheme="https://vaniot-s.github.io/tags/docker/"/>
    
      <category term="jenjins" scheme="https://vaniot-s.github.io/tags/jenjins/"/>
    
  </entry>
  
  <entry>
    <title>算法导论笔记</title>
    <link href="https://vaniot-s.github.io/2018/09/04/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%94%E8%AE%B0/"/>
    <id>https://vaniot-s.github.io/2018/09/04/算法导论笔记/</id>
    <published>2018-09-04T07:56:09.000Z</published>
    <updated>2021-05-06T21:05:19.536Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>算法:由输入经过一系列的计算步骤得到输出</p><p>排序问题：将无序的输入经过处理按照一定的孙徐输出</p><p>优秀的算法： </p><ul><li>正确性(思路清晰)</li><li>高效(算法分析)</li><li>易于实现(现成的算法)</li></ul><p>算法的用处：</p><ul><li>生物信息学</li><li>网络(图论，字符串查找)</li><li>信息安全(RSA..)</li><li>优化(调度)<br>算法问题：</li><li>图论(最短路径…)</li><li>LCS(动态规划…)</li><li>拓扑排序</li><li>凸包</li></ul><p>数据结构：<br>    C++ STL 优缺点 效率</p><p>难解问题:</p><p>并行算法<br>   CPU效率</p><p>算法技术</p><p>算法的效率</p><h2 id="渐近记号"><a href="#渐近记号" class="headerlink" title="渐近记号"></a>渐近记号</h2><p>问题规模量 时间T(n)</p><h2 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;p&gt;算法:由输入经过一系列的计算步骤得到输出&lt;/p&gt;
&lt;p&gt;排序问题：将无序的输
      
    
    </summary>
    
      <category term="basic" scheme="https://vaniot-s.github.io/categories/basic/"/>
    
    
      <category term="算法" scheme="https://vaniot-s.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>docker官方项目</title>
    <link href="https://vaniot-s.github.io/2018/09/03/docker%E5%AE%98%E6%96%B9%E9%A1%B9%E7%9B%AE/"/>
    <id>https://vaniot-s.github.io/2018/09/03/docker官方项目/</id>
    <published>2018-09-03T14:45:23.000Z</published>
    <updated>2021-05-06T21:05:19.536Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="Compose"><a href="#Compose" class="headerlink" title="Compose"></a>Compose</h2><p>   <code>Compose</code>定义和运行多个<code>Docker</code>容器的应用，实现对<code>Docker</code>容器集群的快速编排。通过一个<code>docker-compose.yml</code>模板文件，定义一组相关联的服务(容器应用)为一个项目(由多个服务组成的完整的业务单元)。</p><h3 id="Compose的使用"><a href="#Compose的使用" class="headerlink" title="Compose的使用"></a>Compose的使用</h3><h4 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h4><p>   <code>Compose</code>的命令对象默认指定为项目，使用 <code>docker-compose [COMMAND] --help</code>或<code>docker-compose help[COMMAND]</code>可以查看某个具体命令的使用格式。<br>   <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose [-f=&lt;arg&gt;...] [options] [COMMAND] [ARGS...]</span><br></pre></td></tr></table></figure></p>   <a id="more"></a><h4 id="命令选项"><a href="#命令选项" class="headerlink" title="命令选项"></a>命令选项</h4><ul><li>-f, –file FILE 指定使用的 Compose 模板文件，默认为 docker-compose.yml，可以多次指定。</li><li>-p, –project-name NAME 指定项目名称，默认将使用所在目录名称作为项目名。</li><li>–x-networking 使用 Docker 的可拔插网络后端特性</li><li>–x-network-driver DRIVER 指定网络后端的驱动，默认为 bridge</li><li>–verbose 输出更多调试信息。</li><li><p>-v, –version 打印版本并退出。</p><h4 id="命令使用说明"><a href="#命令使用说明" class="headerlink" title="命令使用说明"></a>命令使用说明</h4></li><li><p>build</p><p>在项目目录下，(重新)构建项目中的容器:<code>docker-compose build [options] [SERVICE...]</code>服务容器构建后将会带上一个标记名。</p><ul><li>–force-rm 删除构建过程中的临时容器</li><li>–no-cache 构建过程中不使用cache</li><li>–pull尝试通过pull获取更新版本的镜像</li></ul></li><li><p>config</p><p>验证Compose文件格式是否正确</p></li><li><p>down</p><p>停止up命令所启动的容器，并删除网络</p></li><li><p>exec</p><p>进入指定的容器</p></li><li><p>help</p><p>获得一个命令的帮助</p></li><li><p>images</p><p>列出Compose文件中包含的镜像</p></li><li><p>kill</p><p><code>docker-compose kill [options] [SERVICE...]</code>通过发送<code>SIGKILL</code>信号强制停止服务容器。带参数<code>-s</code>指定发送信号。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose kill -s SIGINT</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>logs</p><p>查看服务容器的输出，<code>docker-compose</code>对不同的服务输出使用不同的颜色区分，当带有<code>--no-color</code>关闭颜色</p></li><li><p>pause</p><p>暂停一个服务容器,<code>docker-compose pause [SERVICE...]</code></p></li><li><p>port </p><p>打印某个容器端口所映射的公共端口<code>docker-compose port [options] SERVICE PRIVATE_PORT</code></p><ul><li>-protocol=proto 指定端口协议，tcp(默认值)或者udp</li><li>–index=index 同一个服务存在多个容器，指定容器对象的序号</li></ul></li><li><p>ps</p><p>项目中的所有容器<code>docker-compose ps [options][SERVICE...]</code></p><ul><li>-q 只打印容器的ID信息</li></ul></li><li><p>pull </p><p> 拉取服务依赖的镜像<code>docker-compose pull [options][SERVICE...]</code>。</p><ul><li>–ingore-pull-failure 忽略拉取取镜像过程中的错误</li></ul></li><li><p>push</p><p>推送服务依赖的镜像到docker镜像仓库</p></li><li><p>restart</p><p>重启项目中的服务<code>docker-compose restart [options][SERVICE..]</code></p><ul><li>-t,-timeout TIMEOUT指定重启的超时时间(默认10秒) </li></ul></li><li><p>rm </p><p>删除(停止状态的容器)<code>docker-compose rm [options] [SERVICE...]</code></p><ul><li>-f,–force 强制直接删除，包括非停止状态的容器</li><li>-v 删除容器所挂载的数据卷</li></ul></li><li><p>run</p><p>在指定服务上执行命令<code>docker-compose run [options] [-p PORT..][-e KEY=VAL..] SERVICE [COMMAND] [ARGS...]</code><br>指定服务上执行一个命令。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose run ubuntu ping docker.com</span><br></pre></td></tr></table></figure><p>默认会将相关联的(未启动)服务启动，但给定命令将会覆盖原有的自动运行命令，并且不会自动创建端口，以避免冲突。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose run --no-deps web python manage.py shell #--no-deps 不启动关联的容器</span><br></pre></td></tr></table></figure><ul><li>-d 后台运行容器。</li><li>–name NAME 为容器指定一个名字。</li><li>–entrypoint CMD 覆盖默认的容器启动指令。</li><li>-e KEY=VAL 设置环境变量值，可多次使用选项来设置多个环境变量。</li><li>-u, –user=”” 指定运行容器的用户名或者 uid。</li><li>–no-deps 不自动启动关联的服务容器。</li><li>–rm 运行命令后自动删除容器，d 模式下将忽略。</li><li>-p, –publish=[] 映射容器端口到本地主机。</li><li>–service-ports 配置服务端口并映射到本地主机。</li><li>-T 不分配伪 tty，意味着依赖 tty 的指令将无法运行。</li></ul></li><li><p>scale</p><p>设置指定服务运行的容器个数<code>docker-compose scale [options] [SERVICE=NUM...]</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose scale web=3 db=2 #启动3个web服务，2个db服务</span><br></pre></td></tr></table></figure><blockquote><p>当指定的服务大于运行中的容器，创建并启动新的容器，反之，停止多余的容器。</p></blockquote><ul><li>-t,–timeout TIMEOUT停止容器的超时(默认10s)</li></ul></li><li><p>start</p><p>启动已经存在的服务容器<code>docker-compose start [Service...]</code></p></li><li><p>stop</p><p>使运行状态的容器停止<code>docker-compose stop [optins] [SERVICE...]</code></p><ul><li>-t,–timeout TIMEOUT </li></ul></li><li><p>top</p><p>查看各服务容器内运行的进程</p></li><li><p>unpause</p><p>恢复处于暂停状态的服务<code>docker-compose unpause [SERVICE...]</code></p></li><li><p>up</p><p><code>docker-compose up [options] [SERVICE...]</code>将尝试自动完成构建镜像，创建服务，启动服务，关联服务相关的容器，启动关闭的相关容器。默认<code>docker-compose up</code>启动的容器在前台，控制台会打印出所有容器的输出信息。使用<code>docker-compose up -d</code>将在后台启动并运行所有的容器。服务容器已经存在，<code>docker-compose up</code>将会尝试停止容器，然后重新创建（保持使用 <code>volumes-from</code>挂载的卷），以保证新启动的服务匹配 <code>docker-compose.yml</code> 文件的最新内容。如果用户不希望容器被停止并重新创建，可以使用 <code>docker-compose up --no-recreate</code>。这样将只会启动处于停止状态的容器，而忽略已经运行的服务。如果用户只想重新部署某个服务，可以使用 d<code>ocker-compose up --no-deps -d &lt;SERVICE_NAME&gt;</code> 来重新创建服务并后台停止旧服务，启动新服务，并不会影响到其所依赖的服务。</p><ul><li>-d 在后台运行服务容器。</li><li>–no-color 不使用颜色来区分不同的服务的控制台输出。</li><li>–no-deps 不启动服务所链接的容器。</li><li>–force-recreate 强制重新创建容器，不能与 </li><li>–no-recreate 同时使用。</li><li>–no-recreate 如果容器已经存在了，则不重新创建，不能与 –force-recreate 同时使用。</li><li>–no-build 不自动构建缺失的服务镜像。</li><li>-t, –timeout TIMEOUT 停止容器时候的超时（默认为 10 秒）。</li></ul></li><li><p>version </p><p>  打印版本信息 </p><h3 id="compose模板文件"><a href="#compose模板文件" class="headerlink" title="compose模板文件"></a>compose模板文件</h3><p><code>compose</code>文件中的指令说明了构建的服务参数。</p><h4 id="指令详解"><a href="#指令详解" class="headerlink" title="指令详解"></a>指令详解</h4></li><li><p>build </p><p>指定<code>Dockerfile</code>的文件路径(绝对路径或相对<code>docker-compose.yml</code>文件路径)  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 用build指定目录</span><br><span class="line">version: '3'</span><br><span class="line">services:</span><br><span class="line">webapp:</span><br><span class="line">    build: ./dir</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> </span><br><span class="line">version: '3'</span><br><span class="line">services:</span><br><span class="line">webapp:</span><br><span class="line">    build:</span><br><span class="line">        context: ./dir # 使用context指令指定`Dockerfile`所在文件夹的路径</span><br><span class="line">        dockerfile:Dockerfile-alternate # 指定Dockerfile的文件名</span><br><span class="line">        args:</span><br><span class="line">            buildno: 1 # 指令指定构建镜像时的变量</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 使用cache_from 指定构建镜像的缓存</span><br><span class="line">build:</span><br><span class="line">    context: .</span><br><span class="line">    cache_from:</span><br><span class="line">        - alpine:latest</span><br><span class="line">        - corp/web_app:3.14</span><br></pre></td></tr></table></figure></li><li><p>cap_add,cap_drop</p><p>指定容器的内和能力(capacity)分配。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cap_add: # 容器拥有所有的能力</span><br><span class="line"> - ALL</span><br><span class="line">cap_drop: #去掉NET_ADMIN能力</span><br><span class="line"> - NET_ADMIN</span><br></pre></td></tr></table></figure></li><li><p>command</p><p>覆盖容器启动后默认执行的命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">  command: echo "hello world"</span><br><span class="line">  ```  </span><br><span class="line">- configs</span><br><span class="line"></span><br><span class="line">  仅用于`Swarm mode`,</span><br><span class="line"></span><br><span class="line">- cgroup_parent</span><br><span class="line"> </span><br><span class="line">  指定父`cgroup`组,继承该组的资源限制.</span><br><span class="line">  ```shell</span><br><span class="line">  cgroup_parent:cgroup_1</span><br></pre></td></tr></table></figure></li><li><p>container_name<br>指定容器名称，默认会使用<code>项目名称_服务名称_序号</code>的格式</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">container_name:docker-web-container</span><br></pre></td></tr></table></figure><blockquote><p>指定容器名称后，该服务将无法进行扩展（scale），Docker 中不允许多个容器具有相同的名称。</p></blockquote></li><li><p>deploy</p><p>仅用于 Swarm mode</p></li><li><p>devices</p><p>指定设备映射关系。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">devices:</span><br><span class="line">- "/dev/ttyUSB1:/dev/ttyUSB0"</span><br></pre></td></tr></table></figure></li><li><p>depends_on</p><p>解决容器的依赖、启动先后的问题。以下例子中会先启动 redis db 再启动 web</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">version: '3'</span><br><span class="line">services:</span><br><span class="line">web:</span><br><span class="line">    build: .</span><br><span class="line">    depends_on:</span><br><span class="line">    - db</span><br><span class="line">    - redis</span><br><span class="line">redis:</span><br><span class="line">    image: redis</span><br><span class="line">db:</span><br><span class="line">    image: postgres</span><br></pre></td></tr></table></figure><blockquote><p>注意：web 服务不会等待 redis db 「完全启动」之后才启动。</p></blockquote></li><li><p>dns</p><p>自定义 DNS 服务器。可以是一个值，也可以是一个列表。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dns: 8.8.8.8</span><br><span class="line">dns:</span><br><span class="line">- 8.8.8.8</span><br><span class="line">- 114.114.114.114</span><br></pre></td></tr></table></figure></li><li><p>dns_search</p><p>配置 DNS 搜索域。可以是一个值，也可以是一个列表。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dns_search: example.com</span><br><span class="line">dns_search:</span><br><span class="line">- domain1.example.com</span><br><span class="line">- domain2.example.com</span><br></pre></td></tr></table></figure></li><li><p>tmpfs</p><p>挂载一个 tmpfs 文件系统到容器。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tmpfs: /run</span><br><span class="line">tmpfs:</span><br><span class="line">- /run</span><br><span class="line">- /tmp</span><br></pre></td></tr></table></figure></li><li><p>env_file</p><p>从文件中获取环境变量，可以为单独的文件路径或列表。</p><p>如果通过 docker-compose -f FILE 方式来指定 Compose 模板文件，则 env_file 中变量的路径会基于模板文件路径。</p><p>如果有变量名称与 environment 指令冲突，则按照惯例，以后者为准。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">env_file: .env</span><br><span class="line"></span><br><span class="line">env_file:</span><br><span class="line">- ./common.env</span><br><span class="line">- ./apps/web.env</span><br><span class="line">- /opt/secrets.env</span><br></pre></td></tr></table></figure><p>环境变量文件中每一行必须符合格式，支持 # 开头的注释行。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> common.env: Set development environment</span><br><span class="line">PROG_ENV=development</span><br></pre></td></tr></table></figure></li><li><p>environment</p><p>设置环境<br>配置日志选项。组或字典两种格式。</p><p>只给定名<br>配置日志选项。运行 Compose<br>配置日志选项。，可以用来防止泄露不<br>配置日志选项。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">配置日志选项。</span><br><span class="line">environment:</span><br><span class="line">RACK_ENV: development</span><br><span class="line">SESSION_SECRET:</span><br><span class="line">environment:</span><br><span class="line">- RACK_ENV=development</span><br><span class="line">- SESSION_SECRET</span><br></pre></td></tr></table></figure><p>如果变量名称或者值中用到 true|false，yes|no 等表达 布尔 含义的词汇，最好放到引号里，避免 YAML 自动解析某些内容为对应的布尔语义。这些特定词汇，包括</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">y|Y|yes|Yes|YES|n|N|no|No|NO|true|True|TRUE|false|False|on|On|ON|off|Off|OFF</span><br></pre></td></tr></table></figure></li><li><p>expose</p><p>暴露端口，但不映射到宿主机    配置日志选项。连接的服务访问。</p><p>仅可以指定内部端口为参数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">expose:</span><br><span class="line">- "3000"</span><br><span class="line">- "8000"</span><br></pre></td></tr></table></figure></li><li><p>external_links</p><blockquote><p>注意：不建议使用该指令。</p></blockquote><p>链接到 docker-compose.yml 外部的容器，甚至并非 Compose 管理的外部容器。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">external_links:</span><br><span class="line">- redis_1</span><br><span class="line">- project_db_1:mysql</span><br><span class="line">- project_db_1:postgresql</span><br></pre></td></tr></table></figure></li><li><p>extra_hosts</p><p>类似 Docker 中的 –add-host 参数，指定额外的 host 名称映射信息。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">extra_hosts:</span><br><span class="line">- "googledns:8.8.8.8"</span><br><span class="line">- "dockerhub:52.1.157.61"</span><br></pre></td></tr></table></figure><p>会在启动后的服务容器中 /etc/hosts 文件中添加如下两条条目。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">8.8.8.8 googledns</span><br><span class="line">52.1.157.61 dockerhub</span><br></pre></td></tr></table></figure></li><li><p>healthcheck</p><p>通过命令检查容器是否健康运行。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">healthcheck:</span><br><span class="line">test: ["CMD", "curl", "-f", "http://localhost"]</span><br><span class="line">interval: 1m30s</span><br><span class="line">timeout: 10s</span><br><span class="line">retries: 3</span><br></pre></td></tr></table></figure></li><li><p>image</p><p>指定为镜像名称或镜像 ID。如果镜像在本地不存在，Compose 将会尝试拉取这个镜像。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">image: ubuntu</span><br><span class="line">image: orchardup/postgresql</span><br><span class="line">image: a4bc65fd</span><br></pre></td></tr></table></figure></li><li><p>labels</p><p>为容器添加 Docker 元数据（metadata）信息。例如可以为容器添加辅助说明信息。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">labels:</span><br><span class="line">com.startupteam.description: "webapp for a startup team"</span><br><span class="line">com.startupteam.department: "devops department"</span><br><span class="line">com.startupteam.release: "rc3 for v1.0"</span><br></pre></td></tr></table></figure></li><li><p>links</p><blockquote><p>不推荐使用该指令。</p></blockquote></li><li><p>logging<br>配置日志选项。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">logging:</span><br><span class="line">driver: syslog</span><br><span class="line">options:</span><br><span class="line">    syslog-address: "tcp://192.168.0.42:123"</span><br></pre></td></tr></table></figure><p>目前支持三种日志驱动类型。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">driver: "json-file"</span><br><span class="line">driver: "syslog"</span><br><span class="line">driver: "none"</span><br></pre></td></tr></table></figure><p>options 配置日志驱动的相关参数。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">options:</span><br><span class="line">max-size: "200k"</span><br><span class="line">max-file: "10"</span><br></pre></td></tr></table></figure></li><li><p>network_mode</p><p>设置网络模式。使用和 docker run 的 –network 参数一样的值。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">network_mode: "bridge"</span><br><span class="line">network_mode: "host"</span><br><span class="line">network_mode: "none"</span><br><span class="line">network_mode: "service:[service name]"</span><br><span class="line">network_mode: "container:[container name/id]"</span><br></pre></td></tr></table></figure></li><li><p>networks</p><p>配置容器连接的网络。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">version: "3"</span><br><span class="line">services:</span><br><span class="line"></span><br><span class="line">some-service:</span><br><span class="line">    networks:</span><br><span class="line">    - some-network</span><br><span class="line">    - other-network</span><br><span class="line"></span><br><span class="line">networks:</span><br><span class="line">some-network:</span><br><span class="line">other-network:</span><br></pre></td></tr></table></figure></li><li><p>pid</p><p>跟主机系统共享进程命名空间。打开该选项的容器之间，以及容器和宿主机系统之间可以通过进程 ID 来相互访问和操作。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pid: "host"</span><br></pre></td></tr></table></figure></li><li><p>ports</p><p>暴露端口信息。</p><p>使用宿主端口：容器端口 (HOST:CONTAINER) 格式，或者仅仅指定容器的端口（宿主将会随机选择端口）都可以。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ports:</span><br><span class="line">- "3000"</span><br><span class="line">- "8000:8000"</span><br><span class="line">- "49100:22"</span><br><span class="line">- "127.0.0.1:8001:8001"</span><br></pre></td></tr></table></figure><p>注意：当使用 HOST:CONTAINER 格式来映射端口时，如果你使用的容器端口小于 60 并且没放到引号里，可能会得到错误结果，因为 YAML 会自动解析 xx:yy 这种数字格式为 60 进制。为避免出现这种问题，建议数字串都采用引号包括起来的字符串格式。</p></li><li><p>secrets</p><p>存储敏感数据，例如 mysql 服务密码。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">version: "3.1"</span><br><span class="line">services:</span><br><span class="line"></span><br><span class="line">mysql:</span><br><span class="line">image: mysql</span><br><span class="line">environment:</span><br><span class="line">    MYSQL_ROOT_PASSWORD_FILE: /run/secrets/db_root_password</span><br><span class="line">secrets:</span><br><span class="line">    - db_root_password</span><br><span class="line">    - my_other_secret</span><br><span class="line"></span><br><span class="line">secrets:</span><br><span class="line">my_secret:</span><br><span class="line">    file: ./my_secret.txt</span><br><span class="line">my_other_secret:</span><br><span class="line">    external: true</span><br></pre></td></tr></table></figure></li><li><p>security_opt</p><p>指定容器模板标签（label）机制的默认属性（用户、角色、类型、级别等）。例如配置标签的用户名和角色名。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">security_opt:</span><br><span class="line">    - label:user:USER</span><br><span class="line">    - label:role:ROLE</span><br></pre></td></tr></table></figure></li><li><p>stop_signal</p><p>设置另一个信号来停止容器。在默认情况下使用的是 SIGTERM 停止容器。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stop_signal: SIGUSR1</span><br></pre></td></tr></table></figure></li><li><p>sysctls</p><p>配置容器内核参数。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sysctls:</span><br><span class="line">net.core.somaxconn: 1024</span><br><span class="line">net.ipv4.tcp_syncookies: 0</span><br><span class="line"></span><br><span class="line">sysctls:</span><br><span class="line">- net.core.somaxconn=1024</span><br><span class="line">- net.ipv4.tcp_syncookies=0</span><br></pre></td></tr></table></figure></li><li><p>ulimits</p><p>指定容器的 ulimits 限制值。</p><p>例如，指定最大进程数为 65535，指定文件句柄数为 20000（软限制，应用可以随时修改，不能超过硬限制） 和 40000（系统硬限制，只能 root 用户提高）。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ulimits:</span><br><span class="line">    nproc: 65535</span><br><span class="line">    nofile:</span><br><span class="line">    soft: 20000</span><br><span class="line">    hard: 40000</span><br></pre></td></tr></table></figure></li><li><p>volumes</p><p>数据卷所挂载路径设置。可以设置宿主机路径 （HOST:CONTAINER） 或加上访问模式 （HOST:CONTAINER:ro）。</p><p>该指令中路径支持相对路径。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">volumes:</span><br><span class="line">- /var/lib/mysql</span><br><span class="line">- cache/:/tmp/cache</span><br><span class="line">- ~/configs:/etc/configs/:ro</span><br></pre></td></tr></table></figure></li><li><p>其它指令</p><p>此外，还有包括 <code>domainname, entrypoint, hostname, ipc, mac_address, privileged, read_only, shm_size, restart, stdin_open, tty, user, working_dir</code> 等指令，基本跟 docker run 中对应参数的功能一致。</p><p>指定服务容器启动后执行的入口文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">entrypoint: /code/entrypoint.sh</span><br></pre></td></tr></table></figure><p>指定容器中运行应用的用户名。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">user: nginx</span><br></pre></td></tr></table></figure><p>指定容器中工作目录。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">working_dir: /code</span><br></pre></td></tr></table></figure><p>指定容器中搜索域名、主机名、mac 地址等。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">domainname: your_website.com</span><br><span class="line">hostname: test</span><br><span class="line">mac_address: 08-00-27-00-0C-0A</span><br></pre></td></tr></table></figure><p>允许容器中运行一些特权命令。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">privileged: true</span><br></pre></td></tr></table></figure><p>指定容器退出后的重启策略为始终重启。该命令对保持服务始终运行十分有效，在生产环境中推荐配置为 always 或者 unless-stopped。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">restart: always</span><br></pre></td></tr></table></figure><p>以只读模式挂载容器的 root 文件系统，意味着不能对容器内容进行修改。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">read_only: true</span><br></pre></td></tr></table></figure><p>打开标准输入，可以接受外部输入。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stdin_open: true</span><br></pre></td></tr></table></figure><p>模拟一个伪终端。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tty: true</span><br></pre></td></tr></table></figure></li><li><p>读取变量</p><p>Compose 模板文件支持动态读取主机的系统环境变量和当前目录下的 .env 文件中的变量。</p><p>例如，下面的 Compose 文件将从运行它的环境中读取变量 ${MONGO_VERSION} 的值，并写入执行的指令中。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">version: "3"</span><br><span class="line">services:</span><br><span class="line"></span><br><span class="line">db:</span><br><span class="line">image: "mongo:$&#123;MONGO_VERSION&#125;"</span><br></pre></td></tr></table></figure><p>如果执行 MONGO_VERSION=3.2 docker-compose up 则会启动一个 mongo:3.2 镜像的容器；如果执行 MONGO_VERSION=2.8MONGO_VERSION=2.8 docker-compose up 则会启动一个 mongo:2.8 镜像的容器。<br>在当前目录新建 .env 文件并写入以下内容。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 支持 # 号注释</span><br><span class="line">MONGO_VERSION=3.6</span><br></pre></td></tr></table></figure><p>执行 docker-compose up 则会启动一个 mongo:3.6 镜像的容器。</p><h2 id="Machine"><a href="#Machine" class="headerlink" title="Machine"></a>Machine</h2><p><code>docker Machine</code> 用于创建虚拟的 Docker 主机，</p><h2 id="Swarm"><a href="#Swarm" class="headerlink" title="Swarm"></a>Swarm</h2><p><code>Docker Swarm</code>提供<code>Docker</code>容器集群服务，利用<code>Docker Swarm</code>可以将多个<code>Docker</code>主机封装为单个大型的虚拟主机，Docker 1.12 Swarm mode 已经内嵌入 Docker 引擎，成为了 docker 子命令 docker swarm。</p><h3 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h3><h3 id="服务及任务"><a href="#服务及任务" class="headerlink" title="服务及任务"></a>服务及任务</h3></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Compose&quot;&gt;&lt;a href=&quot;#Compose&quot; class=&quot;headerlink&quot; title=&quot;Compose&quot;&gt;&lt;/a&gt;Compose&lt;/h2&gt;&lt;p&gt;   &lt;code&gt;Compose&lt;/code&gt;定义和运行多个&lt;code&gt;Docker&lt;/code&gt;容器的应用，实现对&lt;code&gt;Docker&lt;/code&gt;容器集群的快速编排。通过一个&lt;code&gt;docker-compose.yml&lt;/code&gt;模板文件，定义一组相关联的服务(容器应用)为一个项目(由多个服务组成的完整的业务单元)。&lt;/p&gt;
&lt;h3 id=&quot;Compose的使用&quot;&gt;&lt;a href=&quot;#Compose的使用&quot; class=&quot;headerlink&quot; title=&quot;Compose的使用&quot;&gt;&lt;/a&gt;Compose的使用&lt;/h3&gt;&lt;h4 id=&quot;命令&quot;&gt;&lt;a href=&quot;#命令&quot; class=&quot;headerlink&quot; title=&quot;命令&quot;&gt;&lt;/a&gt;命令&lt;/h4&gt;&lt;p&gt;   &lt;code&gt;Compose&lt;/code&gt;的命令对象默认指定为项目，使用 &lt;code&gt;docker-compose [COMMAND] --help&lt;/code&gt;或&lt;code&gt;docker-compose help[COMMAND]&lt;/code&gt;可以查看某个具体命令的使用格式。&lt;br&gt;   &lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;docker-compose [-f=&amp;lt;arg&amp;gt;...] [options] [COMMAND] [ARGS...]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="web" scheme="https://vaniot-s.github.io/categories/web/"/>
    
    
      <category term="docker" scheme="https://vaniot-s.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>docker基本操作</title>
    <link href="https://vaniot-s.github.io/2018/06/21/docker%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
    <id>https://vaniot-s.github.io/2018/06/21/docker基本操作/</id>
    <published>2018-06-21T19:50:27.000Z</published>
    <updated>2021-05-06T21:05:19.536Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="预操作"><a href="#预操作" class="headerlink" title="预操作"></a>预操作</h2><h3 id="加速器"><a href="#加速器" class="headerlink" title="加速器"></a>加速器</h3><p>  修改<code>/etc/docker/daemon.json</code> 文件并添加上 <code>registry-mirrors</code>键值,将镜像源切换为国内。<br>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> vim /etc/docker/daemon.json </span><br><span class="line">&#123;</span><br><span class="line">"registry-mirrors": ["https://registry.docker-cn.com"]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="设置权限"><a href="#设置权限" class="headerlink" title="设置权限"></a>设置权限</h3><p>  docker守护进程启动的时候，会默认赋予名字为docker的用户组读写Unix socket的权限，创建docker用户组，并将当前用户加入到docker用户组中，当前用户就有权限访问Unix socket了，就可以执行docker相关命令.<br>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo groupadd docker     #添加docker用户组</span><br><span class="line">sudo gpasswd -a $USER docker     #将登陆用户加入到docker用户组中</span><br><span class="line">newgrp docker     #更新用户组</span><br><span class="line">docker ps    #测试docker命令是否可以使用sudo正常使用</span><br></pre></td></tr></table></figure></p>  <a id="more"></a><h2 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h2><p>  Docker镜像由佷多的层次构成，使用<a href="https://en.wikipedia.org/wiki/UnionFS" target="_blank" rel="noopener">Union FS</a>将不同的层结合到一个镜像中。</p><h3 id="获取镜像"><a href="#获取镜像" class="headerlink" title="获取镜像"></a>获取镜像</h3><p>  docker获取镜像的命令：<br>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker pull [选项] [Docker Registry 地址[:端口号]/]仓库名[:标签] #默认的仓库地址为Docker Hub,仓库名为两段式名称，即 &lt;用户名&gt;/&lt;软件名&gt;</span><br><span class="line"></span><br><span class="line">docker pull ubuntu:18.04</span><br></pre></td></tr></table></figure></p><h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><p>  已获取的镜像，作为容器的基础启动<br>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --rm --name ubuntu ubuntu:18.04 bash #run 启动容器 -i 交互操作 -t 终端 --rm 容器退出后会立即删除 --name 命名为ubuntu bash进入shell</span><br></pre></td></tr></table></figure></p><h3 id="查看镜像"><a href="#查看镜像" class="headerlink" title="查看镜像"></a>查看镜像</h3><ul><li><p>列出已经下载的镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image ls # 列表包含了 仓库名、标签、镜像 ID、创建时间 以及 所占用的空间</span><br></pre></td></tr></table></figure><blockquote><p>镜像 ID 则是镜像的唯一标识，一个镜像可以对应多个标签</p></blockquote></li><li><p>查看镜像的体积</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker system shell  #查看镜像、容器、数据卷所占用的空间</span><br></pre></td></tr></table></figure><p>镜像仓库中显示的为压缩后的体积，远大于本地的镜像的体积，除此之外，镜像是多层存储结构，可以继承，复用，不同的镜像使用相同的镜像，故拥有共同的层，实际镜像的占用空间或许会比列表中的占用要小。</p></li><li><p>虚悬镜像<br>当下载已存在的镜像时，原有的镜像的名会被转移到新的镜像，旧有的镜像仓库名、标签均为<code>&lt;none&gt;</code>,被称做为虚悬镜像(dangling image)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker image ls -f dangling=true #只查看虚悬镜像</span><br><span class="line">docker image prune #删除虚悬镜像</span><br></pre></td></tr></table></figure></li><li><p>中间层镜像<br>docker的中间层镜像，是为了加速镜像的构建，重复利用资源，中间层镜像也没有标签，会随着依赖它的镜像删除而被删除。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image ls -a # 查看中间层镜像</span><br></pre></td></tr></table></figure></li><li><p>镜像过滤(列出部分镜像)<br>依据条件列出镜像 –filter(简写为:-f)过滤器参数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker image ls ubuntu # 根据仓库名列出镜像</span><br><span class="line">docker image ls ubuntu:18.04 #根据指定的仓库名和标签列出镜像</span><br><span class="line">docker image ls -f since=ubnutu:18.04 #列出在ubuntu：18.04之后创建的镜像</span><br><span class="line">docker image lf -f before=ubuntu:18.04 # 列出在ubuntu:18.04之前创建的镜像</span><br><span class="line">docker image ls -f label=test #根据Label 过滤，如果镜像创建时定义了</span><br></pre></td></tr></table></figure></li><li><p>特定的格式显示<br>利用参数筛选出镜像的特定的信息,或使用go的模板语法<a href="https://gohugo.io/templates/introduction/" target="_blank" rel="noopener">go的模板语法</a> 指定显示的镜像的信息。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker image ls  -q # 只显示镜像的id</span><br><span class="line">docker image ls  --format "&#123;&#123;.ID&#125;]: &#123;&#123;.Repository&#125;&#125;" #直接列出镜像结果，并且只包含镜像ID和仓库名</span><br><span class="line">docker imagels --format "table &#123;&#123;.ID&#125;&#125;\t&#123;&#123;.Repository&#125;&#125;\t&#123;&#123;.Tag&#125;&#125;" #以表格等距显示，并且有标题行，和默认一样，自己定义列</span><br></pre></td></tr></table></figure></li></ul><h3 id="删除镜像"><a href="#删除镜像" class="headerlink" title="删除镜像"></a>删除镜像</h3><h4 id="删除本地镜像"><a href="#删除本地镜像" class="headerlink" title="删除本地镜像"></a>删除本地镜像</h4>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">  docker image rm --help #查看删除的命令参数</span><br><span class="line">  docker image rm [OPTIONS] IMAGE [IMAGE...] </span><br><span class="line"><span class="meta">  #</span>Aliases: rm, rmi, remove</span><br><span class="line"><span class="meta">  #</span>Options: </span><br><span class="line"><span class="meta">  #</span>   -f, --force Force removal of the image</span><br><span class="line"><span class="meta">  #</span>   --help       Print usage </span><br><span class="line"><span class="meta">  #</span>   --no-prune   Do not delete untagged parents</span><br><span class="line">  docker image rm 501 #使用镜像的短id删除镜像</span><br><span class="line">  docker image rm centos #使用镜像名(&lt;仓库名&gt;:&lt;标签&gt;)删除镜像</span><br><span class="line">  docker image ls --digests #查看镜像并列出摘要</span><br><span class="line">  docker image rm  node@sha256:b4f0e0bdeb578043c1ea6862f0d40cc4afe32a4a582f3be235a3b164422be228 #使用镜像摘要删除镜像</span><br><span class="line">  ``` </span><br><span class="line"><span class="meta">#</span>### Untagged 和 Deleted</span><br><span class="line">  删除标签镜像时，首先会将目标镜像的标签取消，当还有其他的标签指向该镜像时，并不会执行Delete操作。当镜像的层被其他镜像依赖，或有以该镜像为基础的容器，均不会触发Delete操作。</span><br><span class="line"><span class="meta">#</span>### 使用docker image ls 配合删除</span><br><span class="line">  根据查询的结果成批的删除镜像列表</span><br><span class="line">  ```shell</span><br><span class="line">  docker image rm $(docker image ls -q redis)</span><br><span class="line">  docker image rm $(docker image ls -q -f before =mongo:3.2)</span><br></pre></td></tr></table></figure><blockquote><p>CentOS/RHEL 的用户需要注意的事项 ??? <a href="https://yeasy.gitbooks.io/docker_practice/content/image/rm.html#untagged-%E5%92%8C-deleted" target="_blank" rel="noopener">详见</a></p></blockquote><h3 id="镜像的构成"><a href="#镜像的构成" class="headerlink" title="镜像的构成"></a>镜像的构成</h3><p>  docker可用于定制镜像，但一般不用于定制镜像，<code>docker commit</code>会将上一层的镜像跟随当前的存储成而变得臃肿，<code>docker commit</code>生成的尽享对于其他是黑箱操作，不可重复。<code>docker commit</code>一般用于入侵后的现场的保护。<br>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">docker run --name webserver -d -p 8099:80 nginx</span><br><span class="line"><span class="meta">#</span>启动 nginx 容器并将其映射到本地的8099端口 用浏览器打开http:localhost:8099 输出 welcome to Nginx</span><br><span class="line">docker exec -it webserver bash #交互的方式进入容器</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>修改页面的内容</span><br><span class="line">root@b406af708fb8:/# echo '&lt;h1&gt;Hello, Docker!&lt;/h1&gt;' &gt; /usr/share/nginx/html/index.html</span><br><span class="line">root@b406af708fb8:/# exit</span><br><span class="line"><span class="meta">#</span>用浏览器打开http:localhost:8099 输出 Hello Docker</span><br><span class="line">docker diff webserver #查看具体的改动</span><br><span class="line">docker commit --help #查看 commit 的参数</span><br><span class="line"><span class="meta">#</span>docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]]</span><br><span class="line"><span class="meta">#</span> Create a new image from a container's changes</span><br><span class="line"><span class="meta">#</span> Options:</span><br><span class="line"><span class="meta">#</span>   -a, --author string    Author (e.g., "John Hannibal Smith &lt;hannibal@a-team.com&gt;")</span><br><span class="line"><span class="meta">#</span>   -c, --change list      Apply Dockerfile instruction to the created image (default [])</span><br><span class="line"><span class="meta">#</span>       --help             Print usage</span><br><span class="line"><span class="meta">#</span>   -m, --message string   Commit message</span><br><span class="line"><span class="meta">#</span>   -p, --pause            Pause container during commit (default true)</span><br><span class="line"></span><br><span class="line">docker commit -a "vaniot a developer" -m "change the content of index.html" webserver nginx:v2.0 #提交生成新的镜像</span><br><span class="line">docker history nginx:v2.0 #查看nginx:v2.0的变化</span><br></pre></td></tr></table></figure></p><h3 id="Dockerfie定制镜像"><a href="#Dockerfie定制镜像" class="headerlink" title="Dockerfie定制镜像"></a>Dockerfie定制镜像</h3><h4 id="Dockerfile概述"><a href="#Dockerfile概述" class="headerlink" title="Dockerfile概述"></a>Dockerfile概述</h4><p>  Dockerfile是一个文本文件，但不同于<code>shell</code>,包含了许多的指令，每一个指令都将会建立一层。将需要定制的镜像的每一层修改，安装，构建，操作的命令都写入其中。解决重复构建、构建的透明性及体积。</p><h4 id="从dcoker引擎中获取"><a href="#从dcoker引擎中获取" class="headerlink" title="从dcoker引擎中获取"></a>从dcoker引擎中获取</h4><ul><li><p>FROM 指定基础镜像</p><p><code>FROM</code> 为<code>Dockerfile</code>指定了镜像的基础，之后的操作均在其的基础之上进行。</p><blockquote><p>Docker中存在一个空白的镜像名为<code>scratch</code>,以此镜像为基础，则说明之后的指令将作为镜像的第一层开始。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FROM scratch</span><br></pre></td></tr></table></figure></blockquote></li><li><p>RUN 执行命令</p><p>RUN用于执行命令的两种格式：</p><ul><li><p>shell:<code>RUN&lt;命令&gt;</code>,类似与命令行中输入命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RUN echo '&lt;h1&gt;Hello, Docker!&lt;/h1&gt;' &gt; /usr/share/nginx/html/index.html</span><br></pre></td></tr></table></figure></li><li><p>exec: RUN [“可执行文件”, “参数1”, “参数2”]</p></li></ul><blockquote><p><b>ps:</b> 每一个RUN都会创建一层，对于一层中不使用多个<code>RUN</code>，Dockerfile 支持 Shell 类的行尾添加 \ 的命令换行方式，以及行首 # 进行注释的格式。良好的格式，比如换行、缩进、注释等，会让维护、排障更为容易。镜像构建时，一定要确保每一层只添加真正需要添加的东西，任何无关的东西都应该清理掉.</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">FROM debian:jessie</span><br><span class="line"></span><br><span class="line">RUN buildDeps='gcc libc6-dev make' \</span><br><span class="line">  &amp;&amp; apt-get update \</span><br><span class="line">  &amp;&amp; apt-get install -y $buildDeps \</span><br><span class="line">  &amp;&amp; wget -O redis.tar.gz "http://download.redis.io/releases/redis-3.2.5.tar.gz" \</span><br><span class="line">  &amp;&amp; mkdir -p /usr/src/redis \</span><br><span class="line">  &amp;&amp; tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1 \</span><br><span class="line">  &amp;&amp; make -C /usr/src/redis \</span><br><span class="line">  &amp;&amp; make -C /usr/src/redis install \</span><br><span class="line">  &amp;&amp; rm -rf /var/lib/apt/lists/* \</span><br><span class="line">  &amp;&amp; rm redis.tar.gz \</span><br><span class="line">  &amp;&amp; rm -r /usr/src/redis \</span><br><span class="line">  &amp;&amp; apt-get purge -y --auto-remove $buildDeps #执行清理工作</span><br></pre></td></tr></table></figure><p><i>example:</i> 构建nginx</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mkdir nginx #构建空的文件夹</span><br><span class="line">cd nginx </span><br><span class="line">touch Dockerfile </span><br><span class="line"><span class="meta">#</span>在Dockerfile中写入</span><br><span class="line">FROM nginx</span><br><span class="line">RUN echo '&lt;h1&gt;Hello, Docker!&lt;/h1&gt;' &gt; /usr/share/nginx/html/index.html</span><br><span class="line"><span class="meta">#</span>构建镜像</span><br><span class="line">docker build -t nginx:v3 . #构建镜像 `.`不能缺少</span><br><span class="line">docker run  -d -p 8099:80 nginx:v3.0 #创建容器</span><br></pre></td></tr></table></figure><blockquote><p>在docker中<code>.</code>指定了上下文， 对于’docker build’的原理，Docker 运行是分为Docker引擎(服务端守护进程)和客户端工具。Docker 的引擎提供了一组 REST API(<a href="https://docs.docker.com/develop/sdk/" target="_blank" rel="noopener"> Docker Remote API</a>),客户端工具通过API与Docker引擎交互。使用的远程调用形式在服务端（Docker 引擎）完成。<code>docker build</code>命令在服务端构建镜像。用户会指定构建镜像上下文的路径，docker build 命令得知这个路径后，会将路径下的所有内容打包，然后上传给 Docker 引擎。这样 Docker 引擎收到这个上下文包后，展开就会获得构建镜像所需的一切文件。</p></blockquote></li></ul><h4 id="从Git-repo中构建"><a href="#从Git-repo中构建" class="headerlink" title="从Git repo中构建"></a>从Git repo中构建</h4>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build https://github.com/twang2218/gitlab-ce-zh.git#:8.14</span><br></pre></td></tr></table></figure><p>  指定构建所需的 Git repo，并且指定默认的 master 分支，构建目录为 /8.14/，然后 Docker 自己去 git clone 这个项目、切换到指定分支、并进入到指定目录后开始构建。</p><h4 id="使用-tar压缩包构建"><a href="#使用-tar压缩包构建" class="headerlink" title="使用 tar压缩包构建"></a>使用 tar压缩包构建</h4>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build http://server/context.tar.gz</span><br></pre></td></tr></table></figure><p>  Docker 引擎会下载这个包，并自动解压缩，以其作为上下文，开始构建。</p><h4 id="标准输入中读取-Dockerfile-进行构建"><a href="#标准输入中读取-Dockerfile-进行构建" class="headerlink" title="标准输入中读取 Dockerfile 进行构建"></a>标准输入中读取 Dockerfile 进行构建</h4>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build - &lt; Dockerfile # cat Dockerfile | docker build -</span><br></pre></td></tr></table></figure><h4 id="标准输入中读取上下文压缩包进行构建"><a href="#标准输入中读取上下文压缩包进行构建" class="headerlink" title="标准输入中读取上下文压缩包进行构建"></a>标准输入中读取上下文压缩包进行构建</h4>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build - &lt; context.tar.gz</span><br></pre></td></tr></table></figure><h4 id="Dockerfile指令详解"><a href="#Dockerfile指令详解" class="headerlink" title="Dockerfile指令详解"></a>Dockerfile指令详解</h4><ul><li><p>Copy复制文件</p><p>格式有如下两种:</p><ul><li>COPY &lt;源路径&gt; … &lt;目标路径&gt;(类似于命令行)</li><li>COPY [“&lt;源路径1&gt;”,… “&lt;目标路径&gt;”] (类似于函数调用)<br><code>&lt;源路径&gt;</code>可以是多个或者满足Go<code>[filepath.Match](https://golang.org/pkg/path/filepath/#Match)</code>规则的通配符，<code>&lt;目标路径&gt;</code> 可以是容器内的绝对路径，也可以是相对于工作目录的相对路径（工作目录可以用 WORKDIR 指令来指定）。目标路径不需要事先创建，如果目录不存在会在复制文件前先行创建缺失目录。<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">COPY package.json /usr/src/app/ #将构建上下文目录中&lt;源路径&gt;的文件/目录复制到新一层的镜像内的&lt;目标路径&gt;位置</span><br><span class="line">COPY hom* /mydir/</span><br><span class="line">COPY hom?.txt /mydir/</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>使用 <code>COPY</code> 指令，源文件的各种元数据都会保留。比如读、写、执行权限、文件变更时间等。</p></blockquote></li><li><p>ADD 复制文件</p><p><code>ADD</code> 和 <code>COPY</code> 的格式和性质基本一致，<code>ADD</code>可执行更加复杂的更能，<code>ADD</code>允许<code>&lt;源路径&gt;</code>为<code>URL</code>，<code>Docker</code>引擎会下载该链接的文件到<code>&lt;目标文件&gt;</code>并将权限设置为600(若要修改权限需要额外的加一层<code>RUN</code>进行权限的修改),对于下载的压缩包，解压也需要一层<code>RUN</code>指令进行解压(<code>&lt;源路径&gt;</code>为一个 tar 压缩文件的话，压缩格式为 gzip, bzip2 以及 xz 的情况下，ADD 指令将会自动解压缩这个压缩文件到<code>&lt;目标路径&gt;</code>去)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FROM scratch</span><br><span class="line">ADD ubuntu-xenial-core-cloudimg-amd64-root.tar.gz / #自动解压ubuntu镜像</span><br></pre></td></tr></table></figure><blockquote><p>ADD 指令会令镜像构建缓存失效，所有的文件复制均使用 COPY 指令，仅在需要自动解压缩的场合使用 ADD。</p></blockquote></li><li><p>CMD 容器的启动</p><p>容器是一个进程，容器中的应用均应该以<b>前台执行</b>，<code>CMD</code>用于指定默认的容器主进程的启动命令。<code>CMD</code>的两种格式:</p><ul><li>shell：CMD <code>&lt;命令&gt;</code></li><li>exec : CMD [“可执行文件”,”参数1”,”参数2”,…] #解析时会被解析为JSON数组，使用时必须为双引号。<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>Dockerfile</span><br><span class="line">FROM ubuntu:16.04</span><br><span class="line">RUN apt-get update \</span><br><span class="line">  &amp;&amp; apt-get install -y curl \</span><br><span class="line">  &amp;&amp; rm -rf /var/lib/apt/lists/*</span><br><span class="line">CMD [ "curl", "-s", "http://ip.cn" ]</span><br><span class="line"><span class="meta">#</span>build </span><br><span class="line">docker build -t myip 。</span><br><span class="line"><span class="meta">#</span>run </span><br><span class="line">docker run myip #输出当前IP的地址</span><br><span class="line">docker run myip curl -s http://ip.cn -i #覆盖掉之前的CMD 增加http头信息</span><br></pre></td></tr></table></figure></li></ul></li><li><p>ENTRYPOINT </p><p><code>ENTRYPOINT</code>指定容器启动程序及参数，也可通过在<code>docker run</code>时指定参数<code>--entrypoint</code>修改已经指定的<code>EMTRYPOINT</code>容器启动程序及参数。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>Dockerfile</span><br><span class="line">FROM ubuntu:16.04</span><br><span class="line">RUN apt-get update \</span><br><span class="line">  &amp;&amp; apt-get install -y curl \</span><br><span class="line">  &amp;&amp; rm -rf /var/lib/apt/lists/*</span><br><span class="line">ENTRYPOINT [ "curl", "-s", "http://ip.cn" ]</span><br><span class="line"><span class="meta">#</span>build </span><br><span class="line">docker build  -t ip .</span><br><span class="line"><span class="meta">#</span>run </span><br><span class="line">docker run ip</span><br><span class="line">docker run it -i #修改ENTRYPOINT的内容</span><br></pre></td></tr></table></figure></li><li><p>ENV环境变量<br><code>ENV</code>设置环境变量，其值可在其他指令中使用,设置环境变量的格式如下：</p><ul><li><code>ENV &lt;key&gt;&lt;value&gt;</code></li><li><code>ENV &lt;key1&gt;=&lt;value1&gt; &lt;key2&gt;=&lt;value2&gt;...</code><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ENV NODE_VERSION 8.11.4</span><br><span class="line">RUN curl -SLO "https://nodejs.org/dist/v$NODE_VERSION/node-v$NODE_VERSION-linux-x64.tar.xz" \</span><br><span class="line">&amp;&amp; curl -SLO "https://nodejs.org/dist/v$NODE_VERSION/SHASUMS256.txt.asc" \</span><br><span class="line">&amp;&amp; gpg --batch --decrypt --output SHASUMS256.txt SHASUMS256.txt.asc \</span><br><span class="line">&amp;&amp; grep " node-v$NODE_VERSION-linux-x64.tar.xz\$" SHASUMS256.txt | sha256sum -c - \</span><br><span class="line">&amp;&amp; tar -xJf "node-v$NODE_VERSION-linux-x64.tar.xz" -C /usr/local --strip-components=1 \</span><br><span class="line">&amp;&amp; rm "node-v$NODE_VERSION-linux-x64.tar.xz" SHASUMS256.txt.asc SHASUMS256.txt \</span><br><span class="line">&amp;&amp; ln -s /usr/local/bin/node /usr/local/bin/nodejs</span><br></pre></td></tr></table></figure></li></ul></li><li><p>ARG 构建参数</p><p>ARG的作用与<code>ENV</code>相同，用于设置环境变量，但<code>ARG</code>设置的是构建环境变量，在容器运行时不会存在这些环境变量。<code>docker history</code>可以看到<code>ARG</code>的值。<code>Dockerfile</code> 中的 <code>ARG</code> 指令是定义参数名称，以及定义其默认值。格式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ARG &lt;参数名&gt;[=&lt;默认值&gt;]</span><br></pre></td></tr></table></figure><p>该默认值可以在构建命令 <code>docker build</code> 中用 <code>--build-arg &lt;参数名&gt;=&lt;值&gt;</code>来覆盖。</p></li><li><p>VOLUME定义匿名卷</p><p>容器运行时，对于数据库类需要保存数据的应用，其数据哭文件应该保存于卷中，对于容器存储层不发生写操作。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>Dockerfile</span><br><span class="line">VOLUME /data #将/data指定为匿名卷</span><br><span class="line"><span class="meta">#</span>docker run</span><br><span class="line">docker run -d -v mydata:/data xxx # 运行将mydata卷挂在到/data</span><br></pre></td></tr></table></figure></li><li><p>EXPOSE 声明端口<br><code>EXPOSE</code>声明运行是容器提供的服务端口，声明容器打算使用的端口，不会在运行时开启该端口的服务，不会自动在宿主进行端口映射。当<code>docker run -P</code>会自动随机映射<code>EXPOSE</code>的端口。格式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPOSE &lt;端口1&gt; [&lt;端口2&gt;...]</span><br></pre></td></tr></table></figure><blockquote><p>运行时使用<code>-p &lt;宿主端口&gt;:&lt;容器端口&gt;</code>,<code>-p</code>映射宿主端口和容器端口，将容器的对应端口服务公开给外界访问。</p></blockquote></li><li><p>WORKDIR 指定工作目录</p><p><code>WORKDIR</code>指定工作目录，以后的各层的当前目录就被改为指定的目录，如果目录不存在，<code>WORKDIR</code>会建立目录，改变环境状态并影响以后的层。如果需要改变以后各层的工作目录的位置，那么应该使用<code>WORKDIR</code>指令。</p></li><li><p>USER 指定当前用户</p><p><code>USER</code>改变之后层执行<code>RUN</code>,<code>CMD</code>及<code>ENTRYPOINT</code>命令的身份。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 建立 redis 用户，并使用 gosu 换另一个用户执行命令</span><br><span class="line">RUN groupadd -r redis &amp;&amp; useradd -r -g redis redis</span><br><span class="line"><span class="meta">#</span> 下载 gosu</span><br><span class="line">RUN wget -O /usr/local/bin/gosu "https://github.com/tianon/gosu/releases/download/1.7/gosu-amd64" \</span><br><span class="line">&amp;&amp; chmod +x /usr/local/bin/gosu \</span><br><span class="line">&amp;&amp; gosu nobody true</span><br><span class="line"><span class="meta">#</span> 设置 CMD，并以另外的用户执行</span><br><span class="line">CMD [ "exec", "gosu", "redis", "redis-server" ] #以redis 的身份执行</span><br></pre></td></tr></table></figure></li><li><p>HEALTHCHECK 健康检查</p><p><code>HEALTHCHECK</code>检查容器的状态是否正常，镜像在指定了 <code>HEALTHCHECK</code>指令后，用其启动容器，通过<code>docker container ls</code>可以查看，初始状态会为 <code>starting</code>，在<code>HEALTHCHECK</code>指令检查成功后变为<code>healthy</code>，如果连续一定次数失败，则会变为<code>unhealthy</code>。命令格式：</p><ul><li><code>HEALTHCHECK [选项] CMD &lt;命令&gt;：</code>设置检查容器健康状况的命令</li><li><code>HEALTHCHECK NONE：</code>如果基础镜像有健康检查指令，使用这行可以屏蔽掉其健康检查指令</li></ul><p>对于<code>[选项的设置]</code>：</p><ul><li><code>--interval=&lt;间隔&gt;:</code>两次健康检查的间隔，默认为30s</li><li><code>--timeout=&lt;时长&gt;:</code> 检查命令运行超时时间，超过时间默认为30，检查失败</li><li><p><code>--retries=&lt;次数&gt;:</code>当连续失败指定次数后，将容器状态视为<code>unhealthy</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>Dockerfile</span><br><span class="line">FROM nginx</span><br><span class="line">RUN apt-get update &amp;&amp; apt-get install -y curl &amp;&amp; rm -rf /var/lib/apt/lists/*</span><br><span class="line">HEALTHCHECK --interval=5s --timeout=3s \</span><br><span class="line">CMD curl -fs http://localhost/ || exit 1</span><br><span class="line"><span class="meta">#</span>build</span><br><span class="line">docker build -t healthcheck:v1 .</span><br><span class="line"><span class="meta">#</span>run</span><br><span class="line">docker run -d -name web -p 8100:80 healthcheck:v1</span><br><span class="line"><span class="meta">#</span> container ls</span><br><span class="line">docker container ls</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS                    PORTS                  NAMES</span><br><span class="line">5f3d26567fb4        healthcheck:v1      "nginx -g 'daemon ..."   12 seconds ago      Up 10 seconds (healthy)   0.0.0.0:8100-&gt;80/tcp   web</span><br></pre></td></tr></table></figure><p><code>docker inspect</code>查看检查命令的输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">docker inspect --format '&#123;&#123;json .State.Health&#125;&#125;' web | python -m json.tool #输出最近5条检查信息</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  "FailingStreak": 0,</span><br><span class="line">  "Log": [</span><br><span class="line">    &#123;</span><br><span class="line">        "End": "2018-08-24T15:49:19.185224539+08:00",</span><br><span class="line">        "ExitCode": 0,</span><br><span class="line">        "Output": "&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n&lt;title&gt;Welcome to nginx!&lt;/title&gt;\n&lt;style&gt;\n    body &#123;\n        width: 35em;\n        margin: 0 auto;\n        font-family: Tahoma, Verdana, Arial, sans-serif;\n    &#125;\n&lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;h1&gt;Welcome to nginx!&lt;/h1&gt;\n&lt;p&gt;If you see this page, the nginx web server is successfully installed and\nworking. Further configuration is required.&lt;/p&gt;\n\n&lt;p&gt;For online documentation and support please refer to\n&lt;a href=\"http://nginx.org/\"&gt;nginx.org&lt;/a&gt;.&lt;br/&gt;\nCommercial support is available at\n&lt;a href=\"http://nginx.com/\"&gt;nginx.com&lt;/a&gt;.&lt;/p&gt;\n\n&lt;p&gt;&lt;em&gt;Thank you for using nginx.&lt;/em&gt;&lt;/p&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n",</span><br><span class="line">        "Start": "2018-08-24T15:49:19.147078923+08:00"</span><br><span class="line">    &#125;,</span><br><span class="line">    ...</span><br><span class="line">  ], </span><br><span class="line">  "Status": "healthy"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>ONBUILD ？？</p><p><code>ONBUILD</code>之后跟随着其它的指令，这些指令会在以当前镜像为基础镜像时，去构建下一级镜像才会被执行，当前镜像中不会执行，即为下一级的镜像准备。</p></li></ul><h4 id="Dockerfile多阶段构建"><a href="#Dockerfile多阶段构建" class="headerlink" title="Dockerfile多阶段构建"></a>Dockerfile多阶段构建</h4>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>Dockerfile</span><br><span class="line">FROM golang:1.9-alpine as builder #命名为builder的第一阶段</span><br><span class="line">RUN apk --no-cache add git</span><br><span class="line">WORKDIR /go/src/github.com/go/helloworld/</span><br><span class="line">RUN go get -d -v github.com/go-sql-driver/mysql</span><br><span class="line">COPY app.go .</span><br><span class="line">RUN CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o app .</span><br><span class="line">FROM alpine:latest as prod</span><br><span class="line">RUN apk --no-cache add ca-certificates</span><br><span class="line">WORKDIR /root/</span><br><span class="line">COPY --from=0 /go/src/github.com/go/helloworld/app . #从上一阶段复制文件</span><br><span class="line">CMD ["./app"]</span><br><span class="line"><span class="meta">#</span>build</span><br><span class="line">docker build -t go/helloworld:3 .</span><br><span class="line"><span class="meta">#</span>构建其中一阶段的镜像</span><br><span class="line">docker build --target builder -t username/imagename:tag .</span><br></pre></td></tr></table></figure><p>  从镜像中复制文件：<br>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">COPY --from=nginx:latest /etc/nginx/nginx.conf /nginx.conf</span><br></pre></td></tr></table></figure></p><blockquote><p><strong><code>*</code></strong> <a href="https://yeasy.gitbooks.io/docker_practice/appendix/best_practices.html" target="_blank" rel="noopener">Dockerfile 最佳实践文档 </a></p></blockquote><h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><p>  <code>Docker</code>在<code>AUFS</code>上构建的容器，容器是独立运行的一个或一组应用，以及它们的运行态环境。</p><h3 id="启动容器"><a href="#启动容器" class="headerlink" title="启动容器"></a>启动容器</h3><h4 id="基于镜像新建容器"><a href="#基于镜像新建容器" class="headerlink" title="基于镜像新建容器"></a>基于镜像新建容器</h4><p>  新建并启动容器<code>dcoker run</code>,<br>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> docker run 的命令格式</span><br><span class="line">docker run [OPTIONS] IMAGE [COMMAND] [ARG...]</span><br><span class="line"></span><br><span class="line">docker run ubuntu:16.04 /bin/echo "Hello World" #输出一个"Hello world"，之后终止容器</span><br><span class="line">docker run -t -i ubuntu:16.04 /bin/bash #启动一个客户端，允许用户进行交互</span><br></pre></td></tr></table></figure></p><p>  使用<code>docker run</code>会进行如下操作:</p><ul><li>检查本地是否存在指定的镜像，不存在从公有的仓库</li><li>利用镜像创建并启动一个容器</li><li>分配一个文件系统，并在只读的镜像文件层外面挂载一层可读写层</li><li>从宿主机配置的网桥接口中<a href>桥接</a>一个虚拟的接口到容器</li><li>从地址池配置一个IP地址给容器</li><li>执行用户指定的应用程序</li><li>执行完毕后容器被终止<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d ubuntu:16.04 /bin/sh -c "while true; do echo hello world; sleep 1; done" #容器会在后台运行并不会把输出的结果 (STDOUT) 打印到宿主机上(输出结果可以用 docker logs 查看)</span><br></pre></td></tr></table></figure></li></ul><h4 id="将终止的容器重新启动"><a href="#将终止的容器重新启动" class="headerlink" title="将终止的容器重新启动"></a>将终止的容器重新启动</h4><p>  <code>docker container start</code>将一个已经停止的容器启动运行。<br>  <code>docker container restart</code>将运行状态的容器重新启动。</p><h3 id="终止容器"><a href="#终止容器" class="headerlink" title="终止容器"></a>终止容器</h3><p>  <code>docker container stop</code>终止一个运行的容器。</p><h3 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h3><p>  当其东容器时 带有参数<code>-d</code>，容器启动后会进入后台,进入守护态的容器使用<code>dcoker attach</code>或者<code>docker exec</code>命令，</p><h4 id="attach"><a href="#attach" class="headerlink" title="attach"></a><code>attach</code></h4>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker container ls #查看容器</span><br><span class="line"><span class="meta">#</span> CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS                       PORTS                  NAMES</span><br><span class="line"><span class="meta">#</span> 5f3d26567fb4        healthcheck:v1      "nginx -g 'daemon ..."   2 days ago          Up About an hour (healthy)   0.0.0.0:8100-&gt;80/tcp   web</span><br><span class="line"></span><br><span class="line">docker attach web #进入名为web的容器</span><br><span class="line"><span class="meta">#</span>exit时，会导致容器的停止。</span><br></pre></td></tr></table></figure><h4 id="exec"><a href="#exec" class="headerlink" title="exec"></a><code>exec</code></h4><p>  <code>docker exec</code>可以有多个参数，<br>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker  run -dit  healthcheck:v1</span><br><span class="line">b5897d0132</span><br><span class="line">docker exec -it b5897 #exit时，容器不会停止</span><br></pre></td></tr></table></figure></p><h3 id="容器的导入及导出"><a href="#容器的导入及导出" class="headerlink" title="容器的导入及导出"></a>容器的导入及导出</h3><h4 id="导出容器"><a href="#导出容器" class="headerlink" title="导出容器"></a>导出容器</h4><p>  将本地的容器导出,使用<code>docker export</code>。<br>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker export b5897d &gt; healty.tar #将容器快照导出</span><br></pre></td></tr></table></figure></p><h4 id="导入容器快照"><a href="#导入容器快照" class="headerlink" title="导入容器快照"></a>导入容器快照</h4><p>使用<code>docker import</code>从容器快照文件中导入为镜像，<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat healthy.tar | docker import - test/healthcheck:v1.0</span><br></pre></td></tr></table></figure></p><p>通过指定 URL 或者某个目录来导入，例如<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker import http://example.com/exampleimage.tgz example/imagerepo</span><br></pre></td></tr></table></figure></p><h4 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h4><p>使用<code>docker container rm</code>来删除一个处于终止状态的容器。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container rm  trusting_newton</span><br></pre></td></tr></table></figure></p><p>清理所有处于终止状态的容器<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container prune</span><br></pre></td></tr></table></figure></p><h2 id="仓库"><a href="#仓库" class="headerlink" title="仓库"></a>仓库</h2><p>  在注册服务器(Registry：管理仓库的具体服务器)上可以有多个仓库，每个仓库下有多个镜像。</p><h3 id="拉取及推送镜像"><a href="#拉取及推送镜像" class="headerlink" title="拉取及推送镜像"></a>拉取及推送镜像</h3><p>  查找官方仓库中的镜像<br>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker search php #--filter=stars=N 参数指定仅显示收藏数量为 N 以上的镜像</span><br><span class="line">docker pull php #拉取镜像到本地</span><br><span class="line">docker tag php:5.6 vaniot/php:5.6 #在登陆后将本地的镜像退送到docker hub</span><br></pre></td></tr></table></figure></p><blockquote><p>自动创建</p></blockquote><h3 id="私有仓库"><a href="#私有仓库" class="headerlink" title="私有仓库"></a>私有仓库</h3><p>  <code>docker-registry</code>官方提供用于构建私有的镜像仓库，</p><ul><li><p>容器运行<br>获取官方的registry镜像来运行,默认仓库建在容器的<code>/var/lib/registry</code>目录下。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 5000:5000 -v -v /opt/data/registry:/var/lib/registry registry #将上传的镜像放到 /opt/data/registry</span><br></pre></td></tr></table></figure></li><li><p>私有仓库进行操作<br>创建好私有仓库后，使用<code>docker tag</code>标记一个镜像，推送到仓库。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 查看本机已有的镜像</span><br><span class="line">  docker image ls</span><br><span class="line">  docker tag IMAGE[:TAG] [REGISTRY_HOST[:REGISTRY_PORT]/]REPOSITORY[:TAG] </span><br><span class="line"><span class="meta">#</span>将镜标记到本地</span><br><span class="line">  docker tag ubuntu:latest 127.0.0.1:5000/ubuntu:latest</span><br><span class="line"><span class="meta">#</span>推送镜像</span><br><span class="line">  docker push 127.0.0.1:5000/ubuntu:latest</span><br><span class="line"><span class="meta">#</span>查看本地的镜像</span><br><span class="line">  curl 127.0.0.1:5000/v2/_catalog</span><br><span class="line">  &#123;"repositories":["ubuntu"]&#125;</span><br><span class="line"><span class="meta">#</span>删除镜像</span><br><span class="line">  docker image rm 127.0.0.1:5000/ubuntu:latest</span><br><span class="line"><span class="meta">#</span>从私有仓库中下载镜像</span><br><span class="line">  docker pull 127.0.0.1:5000/ubuntu:latest</span><br></pre></td></tr></table></figure></li></ul><h2 id="数据管理"><a href="#数据管理" class="headerlink" title="数据管理"></a>数据管理</h2><p>  对于容器而言数据管理的两中方式：</p><ul><li>数据卷(Volumes)</li><li>挂载主机目录(Bind mounts)<h3 id="数据卷-Volumes"><a href="#数据卷-Volumes" class="headerlink" title="数据卷 (Volumes)"></a>数据卷 (Volumes)</h3><code>数据卷</code>是一个可供一个或多个容器使用的特殊目录，理解为多个容器共享的文件目录，与宿主机，容器无关，绕过了<code>UFS</code>，数据卷设计用于持久化数据，其生命周期独立于容器，<code>数据卷</code>不会在容器被删除后自动删除<code>数据卷</code>。</li><li><code>数据卷</code>可以在容器之间共享和重用</li><li><code>数据卷</code>的修改会立即生效</li><li><code>数据卷</code>的改变不会影响到镜像</li><li><code>数据卷</code>默认会一直存在，即使容器被删除<h4 id="数据卷的操作"><a href="#数据卷的操作" class="headerlink" title="数据卷的操作"></a>数据卷的操作</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 数据卷的创建</span><br><span class="line">docker volume create volume-test</span><br><span class="line"><span class="meta">#</span> 查看所有的数据卷</span><br><span class="line">docker volume ls</span><br><span class="line"><span class="meta">#</span>查看制定数据卷的详细信息</span><br><span class="line"> docker volume inspect volume-test</span><br><span class="line"><span class="meta">  #</span>      [</span><br><span class="line"><span class="meta">  #</span>     &#123;</span><br><span class="line"><span class="meta">  #</span>         "CreatedAt": "2018-08-30T23:16:20+08:00",</span><br><span class="line"><span class="meta">  #</span>         "Driver": "local",</span><br><span class="line"><span class="meta">  #</span>         "Labels": &#123;&#125;,</span><br><span class="line"><span class="meta">  #</span>         "Mountpoint": "/var/lib/docker/volumes/volume-test/_data",</span><br><span class="line"><span class="meta">  #</span>         "Name": "volume-test",</span><br><span class="line"><span class="meta">  #</span>         "Options": &#123;&#125;,</span><br><span class="line"><span class="meta">  #</span>         "Scope": "local"</span><br><span class="line"><span class="meta">  #</span>     &#125;</span><br><span class="line"><span class="meta">  #</span> ]</span><br></pre></td></tr></table></figure></li></ul><h4 id="容器中使用数据卷"><a href="#容器中使用数据卷" class="headerlink" title="容器中使用数据卷"></a>容器中使用数据卷</h4><p>  容器中挂载数据卷，使用<code>--mount</code>标记将<code>数据卷</code>挂载到容器里，<code>docker run</code>时可以挂载多个<code>数据卷</code>。<br>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -P --name web  --mount source=volume-test,target=/webapp training/webapp python app.py  #创建一个名为 web 的容器，并加载一个 数据卷 到容器的 /webapp 目录。</span><br><span class="line">docker inspect web </span><br><span class="line"><span class="meta">#</span> #mount 的信息</span><br><span class="line"><span class="meta">#</span>  "Mounts": [</span><br><span class="line"><span class="meta">#</span>         &#123;</span><br><span class="line"><span class="meta">#</span>             "Type": "volume",</span><br><span class="line"><span class="meta">#</span>             "Name": "volume-test",</span><br><span class="line"><span class="meta">#</span>             "Source": "/var/lib/docker/volumes/volume-test/_data",</span><br><span class="line"><span class="meta">#</span>             "Destination": "/webapp",</span><br><span class="line"><span class="meta">#</span>             "Driver": "local",</span><br><span class="line"><span class="meta">#</span>             "Mode": "z",</span><br><span class="line"><span class="meta">#</span>             "RW": true,</span><br><span class="line"><span class="meta">#</span>             "Propagation": ""</span><br><span class="line"><span class="meta">#</span>         &#125;</span><br><span class="line"><span class="meta">#</span>     ],</span><br></pre></td></tr></table></figure></p><h4 id="删除数据卷"><a href="#删除数据卷" class="headerlink" title="删除数据卷"></a>删除数据卷</h4>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker volume rm volume-test #删除数据卷</span><br><span class="line">docker rm -v  #删除容器时并删除数据卷</span><br><span class="line">docker volume prune #清理数据卷</span><br></pre></td></tr></table></figure><h3 id="挂载主机目录"><a href="#挂载主机目录" class="headerlink" title="挂载主机目录"></a>挂载主机目录</h3><p>  <code>docker</code>挂载目录可以使用<code>--mount</code>和<code>-v</code>指定一个本地主机的目录挂载到容器中去。当本地不存在指定的文件，<code>-v</code>的指令会在本地创建文件夹，而<code>--mount</code>则会报错。<br>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>使用--mount挂载文件</span><br><span class="line">docker run -d -P --name web --mount type=bind,source=/src/webapp,target=/opt/webapp training/webapp python app.py</span><br><span class="line"><span class="meta">#</span> 使用-v 挂载文件</span><br><span class="line"> docker run -d -P --name web  -v /src/webapp:/opt/webapp:ro --mount type=bind,source=/src/webapp, target=/opt/webapptraining/webapp python app.py</span><br></pre></td></tr></table></figure></p><blockquote><p><code>Docker</code>挂载宿主机目录默认权限为<code>读写</code>,当增加指令为<code>readonly</code>则为<code>只读</code><br>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -P \</span><br><span class="line"> --name web \</span><br><span class="line"><span class="meta"> #</span> -v /src/webapp:/opt/webapp:ro \</span><br><span class="line"> --mount type=bind,source=/src/webapp,target=/opt/webapp,readonly \</span><br><span class="line"> training/webapp \</span><br><span class="line"> python app.py</span><br></pre></td></tr></table></figure></p></blockquote><h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><h3 id="外部访问容器"><a href="#外部访问容器" class="headerlink" title="外部访问容器"></a>外部访问容器</h3><p>  当外部需要访问容器中的网络应用，通过<code>-p</code>或<code>-P</code>指定端口映射。使用<code>-P</code>，<code>DOcker</code>会随机映射一个<code>49000-49900</code>的端口到内部容器开放的网络端口。</p><h4 id="映射所有接口地址"><a href="#映射所有接口地址" class="headerlink" title="映射所有接口地址"></a>映射所有接口地址</h4><p>  使用 hostPort:containerPort 格式本地的 5000 端口映射到容器的 5000 端口，可以执行<br>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> docker run -d -p 5000:5000 training/webapp python app.py</span><br></pre></td></tr></table></figure></p><p>  此时默认会绑定本地所有接口上的所有地址。</p><h4 id="映射到指定地址的指定端口"><a href="#映射到指定地址的指定端口" class="headerlink" title="映射到指定地址的指定端口"></a>映射到指定地址的指定端口</h4><p>  可以使用 ip:hostPort:containerPort 格式指定映射使用一个特定地址，比如 localhost 地址 127.0.0.1<br>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> docker run -d -p 127.0.0.1:5000:5000 training/webapp python app.py</span><br></pre></td></tr></table></figure></p><h4 id="映射到指定地址的任意端口"><a href="#映射到指定地址的任意端口" class="headerlink" title="映射到指定地址的任意端口"></a>映射到指定地址的任意端口</h4><p>  使用 ip::containerPort 绑定 localhost 的任意端口到容器的 5000 端口，本地主机会自动分配一个端口。<br>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> docker run -d -p 127.0.0.1::5000 training/webapp python app.py</span><br></pre></td></tr></table></figure></p><p>  还可以使用 udp 标记来指定 udp 端口<br>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> docker run -d -p 127.0.0.1:5000:5000/udp training/webapp python app.py</span><br></pre></td></tr></table></figure></p><h4 id="查看映射端口配置"><a href="#查看映射端口配置" class="headerlink" title="查看映射端口配置"></a>查看映射端口配置</h4><p><code>docker port</code>可用于查看当前映射的端口配置。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker port containerName port</span><br></pre></td></tr></table></figure></p><blockquote><ul><li>容器有自己的内部网络和 ip 地址（使用 docker inspect 可以获取所有的变量，Docker 还可以有一个可变的网络配置。）</li><li>-p 标记可以多次使用来绑定多个端口</li></ul></blockquote><h3 id="容器的互联"><a href="#容器的互联" class="headerlink" title="容器的互联"></a>容器的互联</h3><p>  容器的互联可使用<code>--link</code>参数，但更优的选择是使用自定义<code>Docker</code>网络连接。</p><h4 id="新建网络"><a href="#新建网络" class="headerlink" title="新建网络"></a>新建网络</h4><p>  <code>-d</code>指定<code>Docker</code>网络类型，类型为<code>bridge</code>或<code>overlay</code>(overlay适用于Swarm)<br>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  docker  network create -d bridge net-test</span><br><span class="line">  ```  </span><br><span class="line"><span class="meta">#</span>### 连接容器</span><br><span class="line">  运行一个容器并连接到新建的 net-test 网络</span><br><span class="line">  ```shell</span><br><span class="line">    docker run -it --rm --name busybox1 --network net-test busybox sh</span><br><span class="line">    docker run -it --rm --name busybox2 --network net-test busybox sh</span><br></pre></td></tr></table></figure></p><p>  通过<code>ping</code>查看<code>busybox1</code>与<code>busybox2</code>容器建立了联系。<br>  在<code>busybox1</code>中<br>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> ping busybox2</span><br></pre></td></tr></table></figure></p><p>  在<code>busybox2</code>中<br>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> ping busybox1</span><br></pre></td></tr></table></figure></p><blockquote><p>多个容器之间需要互相连接，使用<code>Docker Compose</code>。</p></blockquote><h3 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h3><p>  配置所有<code>Docker</code>容器的DNs可通过：</p><ul><li><code>etc/resolv.conf</code></li><li>配置<code>etc/docker/daemon.json</code>配置<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  "dns" : [</span><br><span class="line">    "114.114.114.114",</span><br><span class="line">    "8.8.8.8"</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>根据<a href="https://yeasy.gitbooks.io/docker_practice/content/introduction/" target="_blank" rel="noopener">docker practice</a>整理而来。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;预操作&quot;&gt;&lt;a href=&quot;#预操作&quot; class=&quot;headerlink&quot; title=&quot;预操作&quot;&gt;&lt;/a&gt;预操作&lt;/h2&gt;&lt;h3 id=&quot;加速器&quot;&gt;&lt;a href=&quot;#加速器&quot; class=&quot;headerlink&quot; title=&quot;加速器&quot;&gt;&lt;/a&gt;加速器&lt;/h3&gt;&lt;p&gt;  修改&lt;code&gt;/etc/docker/daemon.json&lt;/code&gt; 文件并添加上 &lt;code&gt;registry-mirrors&lt;/code&gt;键值,将镜像源切换为国内。&lt;br&gt;  &lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;$&lt;/span&gt; vim /etc/docker/daemon.json &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&quot;registry-mirrors&quot;: [&quot;https://registry.docker-cn.com&quot;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;设置权限&quot;&gt;&lt;a href=&quot;#设置权限&quot; class=&quot;headerlink&quot; title=&quot;设置权限&quot;&gt;&lt;/a&gt;设置权限&lt;/h3&gt;&lt;p&gt;  docker守护进程启动的时候，会默认赋予名字为docker的用户组读写Unix socket的权限，创建docker用户组，并将当前用户加入到docker用户组中，当前用户就有权限访问Unix socket了，就可以执行docker相关命令.&lt;br&gt;  &lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;sudo groupadd docker     #添加docker用户组&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sudo gpasswd -a $USER docker     #将登陆用户加入到docker用户组中&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;newgrp docker     #更新用户组&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;docker ps    #测试docker命令是否可以使用sudo正常使用&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="web" scheme="https://vaniot-s.github.io/categories/web/"/>
    
    
      <category term="docker" scheme="https://vaniot-s.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>ubuntu 安装redis和memcache</title>
    <link href="https://vaniot-s.github.io/2018/06/21/ubuntu-%E5%AE%89%E8%A3%85redis%E5%92%8Cmemcache/"/>
    <id>https://vaniot-s.github.io/2018/06/21/ubuntu-安装redis和memcache/</id>
    <published>2018-06-21T19:46:08.000Z</published>
    <updated>2021-05-06T21:05:19.536Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="安装Redis及启动"><a href="#安装Redis及启动" class="headerlink" title="安装Redis及启动"></a>安装Redis及启动</h2><p>  安装Redis<br>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install redis-server</span><br></pre></td></tr></table></figure></p><p>  启动服务<br>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/init.d/redis-server start</span><br></pre></td></tr></table></figure></p><p> 连接服务<br>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli</span><br></pre></td></tr></table></figure></p><p>  查看redis的密码<br>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">config get requirepass</span><br></pre></td></tr></table></figure></p><p>  设置redis密码<br>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">config set  requirepass 12345</span><br></pre></td></tr></table></figure></p><p>  进入redis<br>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -h 127.0.0.1 -p 6379 -a 12345</span><br></pre></td></tr></table></figure></p><h2 id="php安装redis扩展"><a href="#php安装redis扩展" class="headerlink" title="php安装redis扩展"></a>php安装redis扩展</h2><p>1.下载phpredis扩展文件</p><p>如果服务器没有安装git服务，下载之前，首先安装一下git服务，这里不做描述，自行百度<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/phpredis/phpredis.git</span><br></pre></td></tr></table></figure></p><p>2.移动文件<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv phpredis(此处是你clone下的文件) /etc/phpredis</span><br></pre></td></tr></table></figure></p><p>3.安装<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /etc/phpredis</span><br><span class="line">phpize</span><br></pre></td></tr></table></figure></p><p>如果phpize命令没有响应，可能是没有安装php-dev。我目前安装的是php7.0，键入命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install php7.0-dev</span><br></pre></td></tr></table></figure></p><p>然后再phpize</p><p>4.编译</p><p>依次键入命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./configure</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure></p><p>5.修改配置文件<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/php/7.0/apache2/php.ini</span><br><span class="line">/php_shmop（查找字符串）</span><br></pre></td></tr></table></figure></p><p>然后添加一行<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">extension=/etc/phpredis/modules/redis.so</span><br></pre></td></tr></table></figure></p><p>6.重启apache2<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/init.d/apache2 restart</span><br></pre></td></tr></table></figure></p><p>检查是否安装</p><p>写个phpinfo.php文件<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">     phpinfo();</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure></p><p>访问phpinfo.php，看看是否有redis模块</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;h2 id=&quot;安装Redis及启动&quot;&gt;&lt;a href=&quot;#安装Redis及启动&quot;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Laravel-provider</title>
    <link href="https://vaniot-s.github.io/2018/05/09/Laravel-provider/"/>
    <id>https://vaniot-s.github.io/2018/05/09/Laravel-provider/</id>
    <published>2018-05-09T09:40:56.000Z</published>
    <updated>2021-05-06T21:05:19.536Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>todo~~</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;p&gt;todo~~&lt;/p&gt;

      
    
    </summary>
    
      <category term="web" scheme="https://vaniot-s.github.io/categories/web/"/>
    
    
      <category term="Laravel" scheme="https://vaniot-s.github.io/tags/Laravel/"/>
    
      <category term="provider" scheme="https://vaniot-s.github.io/tags/provider/"/>
    
  </entry>
  
</feed>
